{"version":3,"file":"background.js","sources":["../../src/utils/scheduleUtils.ts","../../src/utils/request.ts","../../src/utils/imageUtils.ts","../../src/utils/scheduleTriggerService.ts","../../src/content/background.ts"],"sourcesContent":["// src/utils/scheduleUtils.ts\n\n// Schedule data interface\nexport interface Schedule {\n  scheduleId: string;\n  userId: string;\n  timestamp: number;\n  substackNoteId?: string;\n  isProcessing?: boolean;\n}\n// Storage key for schedules\nconst SCHEDULES_STORAGE_KEY = \"writestack_schedules\";\n\n/**\n * Create a new schedule\n * @param scheduleId Unique identifier for the schedule\n * @param userId User identifier\n * @param timestamp Unix timestamp when the schedule should trigger\n * @returns Promise resolving to the created schedule\n */\nexport async function createSchedule(\n  scheduleId: string,\n  userId: string,\n  timestamp: number\n): Promise<Schedule> {\n  // Validate parameters\n  if (!scheduleId || !userId || !timestamp) {\n    throw new Error(\"Invalid schedule parameters\");\n  }\n\n  // Get existing schedules\n  const existingSchedules = await getSchedules();\n\n  // Check if schedule with same ID already exists\n  const scheduleExists = existingSchedules.some(\n    (schedule) => schedule.scheduleId === scheduleId\n  );\n  if (scheduleExists) {\n    throw new Error(`Schedule with ID ${scheduleId} already exists`);\n  }\n\n  // Create new schedule\n  const newSchedule: Schedule = {\n    scheduleId,\n    userId,\n    timestamp,\n  };\n\n  // Add schedule to storage\n  const updatedSchedules = [...existingSchedules, newSchedule];\n  await saveSchedules(updatedSchedules);\n\n  // Create an alarm for this schedule\n  await createAlarmForSchedule(newSchedule);\n\n  console.log(\n    `Schedule created: ${scheduleId} at ${new Date(timestamp).toISOString()}`\n  );\n  return newSchedule;\n}\n\n/**\n * Delete a schedule by ID\n * @param scheduleId ID of the schedule to delete\n * @returns Promise resolving to boolean indicating success\n */\nexport async function deleteSchedule(scheduleId: string): Promise<boolean> {\n  // Get existing schedules\n  const existingSchedules = await getSchedules();\n\n  // Filter out the schedule to delete\n  const updatedSchedules = existingSchedules.filter(\n    (schedule) => schedule.scheduleId !== scheduleId\n  );\n\n  // If no schedule was removed, return true\n  if (updatedSchedules.length === existingSchedules.length) {\n    return true;\n  }\n\n  // Delete the alarm for this schedule\n  try {\n    await chrome.alarms.clear(scheduleId);\n    // delete from storage\n  } catch (error) {\n    console.error(`Failed to clear alarm for schedule ${scheduleId}:`, error);\n  }\n\n  // Save updated schedules\n  await saveSchedules(updatedSchedules);\n  console.log(`Schedule deleted: ${scheduleId}`);\n  return true;\n}\n\n/**\n * Get all schedules\n * @returns Promise resolving to array of schedules\n */\nexport async function getSchedules(): Promise<Schedule[]> {\n  try {\n    const result = await chrome.storage.local.get(SCHEDULES_STORAGE_KEY);\n    return result[SCHEDULES_STORAGE_KEY] || [];\n  } catch (error) {\n    console.error(\"Failed to get schedules:\", error);\n    return [];\n  }\n}\n\n/**\n * Save schedules to storage\n * @param schedules Array of schedules to save\n * @returns Promise that resolves when schedules are saved\n */\nexport async function saveSchedules(schedules: Schedule[]): Promise<void> {\n  try {\n    console.log(\"Saving schedules\", schedules);\n    await chrome.storage.local.set({ [SCHEDULES_STORAGE_KEY]: schedules });\n  } catch (error) {\n    console.error(\"Failed to save schedules:\", error);\n    throw new Error(\"Failed to save schedules\");\n  }\n}\n\n// /**\n//  * Finds all duplicate alarms and removes them\n//  * @param schedule\n//  */\n// async function clearDuplicateAlarms(): Promise<void> {\n//   try {\n//     console.log(\"Clearing duplicate alarms\");\n//     const allAlarms = await chrome.alarms.getAll();\n//     // go over all alarms and remove duplicates\n//     for (const alarm of allAlarms) {\n//       const duplicateAlarm = allAlarms.find(\n//         (a) => a.name === alarm.name && a.scheduledTime === alarm.scheduledTime\n//       );\n//       if (duplicateAlarm) {\n//         console.log(\"Clearing duplicate alarm\", duplicateAlarm.name);\n//         await chrome.alarms.clear(duplicateAlarm.name);\n//       }\n//     }\n//   } catch (error) {\n//     console.error(\"Failed to clear duplicate alarms:\", error);\n//   }\n// }\n\n/**\n * Create a Chrome alarm for a schedule\n * @param schedule Schedule to create alarm for\n */\nasync function createAlarmForSchedule(schedule: Schedule): Promise<void> {\n  try {\n    // Create alarm with schedule ID as name\n    console.log(\"Creating alarm for schedule\", schedule.scheduleId);\n    const allAlarms = await chrome.alarms.getAll();\n    if (allAlarms.find((a) => a.name === schedule.scheduleId)) {\n      console.log(\"Alarm already exists for schedule\", schedule.scheduleId);\n      return;\n    }\n    chrome.alarms.create(schedule.scheduleId, {\n      when: schedule.timestamp,\n    });\n    // await clearDuplicateAlarms();\n    console.log(\n      `Alarm created for schedule ${schedule.scheduleId} at ${new Date(\n        schedule.timestamp\n      ).toISOString()}`\n    );\n  } catch (error) {\n    console.error(\n      `Failed to create alarm for schedule ${schedule.scheduleId}:`,\n      error\n    );\n    throw new Error(\"Failed to create alarm for schedule\");\n  }\n}\n","const API_BASE_URL = \"https://www.writestack.io\";\n// const API_BASE_URL = \"http://localhost:3000\";\n\nexport async function makeAuthenticatedRequest(\n  endpoint: string,\n  options: RequestInit = {},\n  baseUrl?: string\n) {\n  try {\n    let url = `${baseUrl || API_BASE_URL}/${endpoint}`;\n    // replace accidental double \\\\ with single \\\n    url = url.replace(\"\\\\\\\\\", \"\\\\\");\n    console.log(\"Making request\", url, options);\n    const response = await fetch(url, {\n      ...options,\n      credentials: \"include\", // Include cookies automatically\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options.headers,\n      },\n    });\n\n    if (!response.ok) {\n      const text = await response.text();\n      console.log(\"Request failed\", response.status, text);\n      return {\n        success: false,\n        error: text,\n        status: response.status,\n      };\n    }\n\n    const json = await response.json();\n    console.log(\"Response json\", json);\n\n    return {\n      success: true,\n      data: json,\n      status: response.status,\n    };\n  } catch (error: any) {\n    console.error(\"Request failed\", error);\n    return {\n      success: false,\n      error: error.message,\n      status: 500,\n    };\n  }\n}\n","// src/utils/imageUtils.ts\n\n// Interface for Substack image returned from API\nexport interface NoteDraftImage {\n  id: string;\n  url: string;\n}\n\n// Interface for Substack image response\ninterface SubstackImageResponse {\n  id: string;\n  imageUrl: string;\n  imageWidth: number;\n  imageHeight: number;\n  explicit: boolean;\n}\n\n/**\n * Download an image from a URL and return it as Uint8Array\n * @param url URL of the image to download\n * @returns Promise resolving to Uint8Array of image data or null if failed\n */\nexport async function downloadImage(url: string): Promise<Uint8Array | null> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      const responseText = await response.text();\n      console.error(\n        `Failed to fetch image from ${url}, got status: ${response.status}, response: ${responseText}`\n      );\n      return null;\n    }\n\n    const arrayBuffer = await response.arrayBuffer();\n    return new Uint8Array(arrayBuffer);\n  } catch (error) {\n    console.error(`Error downloading image from ${url}:`, error);\n    return null;\n  }\n}\n\n/**\n * Upload an image to Substack\n * @param image Image data as Uint8Array\n * @param userId User ID\n * @param noteId Note ID\n * @returns Promise resolving to the uploaded image data\n */\nexport async function uploadImageSubstack(\n  image: Uint8Array\n): Promise<NoteDraftImage> {\n  if (!image) {\n    throw new Error(\"Invalid image data\");\n  }\n\n  try {\n    // Convert image to base64\n    const base64 = arrayBufferToBase64(image);\n    const dataUri = `data:image/png;base64,${base64}`;\n\n    console.log(\"Uploading image to Substack\", dataUri);\n\n    // Upload image to Substack\n    const uploadImageResponse = await fetch(\n      \"https://substack.com/api/v1/image\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n          \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        },\n        body: JSON.stringify({ image: dataUri }),\n        method: \"POST\",\n      }\n    );\n\n    if (!uploadImageResponse.ok) {\n      const responseText = await uploadImageResponse.text();\n      console.error(`Failed to upload image to Substack: ${responseText}`);\n      throw new Error(\"Failed to upload image to Substack\");\n    }\n\n    const data = await uploadImageResponse.json();\n\n    // Get image attachment from Substack\n    const getImageResponse = await fetch(\n      \"https://substack.com/api/v1/comment/attachment\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n          \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        },\n        method: \"POST\",\n        body: JSON.stringify({ type: \"image\", url: data.url }),\n      }\n    );\n\n    if (!getImageResponse.ok) {\n      const responseText = await getImageResponse.text();\n      console.error(`Failed to get image from Substack: ${responseText}`);\n      throw new Error(\"Failed to get image from Substack\");\n    }\n\n    const imageData: SubstackImageResponse = await getImageResponse.json();\n\n    // Store the image info\n    const noteDraftImage: NoteDraftImage = {\n      id: imageData.id,\n      url: imageData.imageUrl,\n    };\n\n    console.log(`Image uploaded to Substack: ${noteDraftImage.id}`);\n    return noteDraftImage;\n  } catch (error) {\n    console.error(\"Error uploading image to Substack:\", error);\n    throw new Error(\"Failed to upload image to Substack\");\n  }\n}\n\n/**\n * Convert Uint8Array to base64 string\n * @param buffer Uint8Array to convert\n * @returns Base64 string\n */\nfunction arrayBufferToBase64(buffer: Uint8Array): string {\n  let binary = \"\";\n  const bytes = new Uint8Array(buffer);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\n/**\n * Prepare multiple attachments for a note\n * @param urls Array of image URLs to upload\n * @param userId User ID\n * @param noteId Note ID\n * @returns Promise resolving to array of uploaded images\n */\nexport async function prepareAttachmentsForNote(\n  urls: string[],\n): Promise<NoteDraftImage[]> {\n  if (!urls || urls.length === 0) {\n    return [];\n  }\n\n  const maxAttachments = 4;\n  const attachmentsToUpload = urls.slice(0, maxAttachments);\n  const attachments: NoteDraftImage[] = [];\n\n  console.log(\"Uploading attachments\", attachmentsToUpload);\n\n  for (const url of attachmentsToUpload) {\n    try {\n      // Download the image\n      const buffer = await downloadImage(url);\n      if (!buffer) {\n        console.error(`Failed to download image from ${url}`);\n        continue;\n      }\n\n      console.log(\"Got buffer! with length\", buffer.length);\n\n      // Upload to Substack\n      const substackImage = await uploadImageSubstack(buffer);\n      attachments.push(substackImage);\n    } catch (error) {\n      console.error(`Error processing attachment from ${url}:`, error);\n    }\n  }\n\n  return attachments;\n}\n","import { makeAuthenticatedRequest } from \"@/utils/request\";\nimport { NoteDraftImage, prepareAttachmentsForNote } from \"./imageUtils\";\nimport { getSchedules, saveSchedules, Schedule } from \"./scheduleUtils\";\n\n// API endpoint for schedule triggers\nconst getScheduleTriggerAPI = (scheduleId: string) =>\n  `api/v1/extension/schedule/${scheduleId}/triggered`;\nconst getScheduleAPI = (scheduleId: string) =>\n  `api/v1/extension/schedule/${scheduleId}`;\n// TODO: Make sure that if writestack.io is open, open a new Substack tab to send the post.\n\n// Response from the API when a schedule is triggered\ninterface ScheduleTriggerResponse {\n  jsonBody: any;\n  attachmentUrls: string[];\n}\n\n// Result of posting to Substack\ninterface PostToSubstackResult {\n  success: boolean;\n  error?: string;\n  data?: any;\n}\n\n/**\n * Handle a triggered schedule\n * @param schedule The schedule that was triggered\n * @returns Promise that resolves when the schedule has been handled\n */\nexport async function handleScheduleTrigger(schedule: Schedule): Promise<void> {\n  console.log(`Handling triggered schedule: ${schedule.scheduleId}`);\n\n  const schedules = await getSchedules();\n  const freshSchedule = schedules.find(\n    (s) => s.scheduleId === schedule.scheduleId\n  );\n  if (!freshSchedule || freshSchedule.isProcessing) {\n    console.warn(`Skipping already processing schedule ${schedule.scheduleId}`);\n    return;\n  }\n  try {\n    // update the schedule as processing\n    freshSchedule.isProcessing = true;\n    await saveSchedules([\n      ...schedules.filter((s) => s.scheduleId !== schedule.scheduleId),\n      freshSchedule,\n    ]);\n\n    // Notify the API that a schedule has been triggered\n    const response = await getSchedule(schedule.scheduleId);\n    console.log(\"getSchedule response\", response);\n    // If the jsonBody is empty, notify the API of the error\n    if (!response || !response.jsonBody) {\n      console.error(`Empty body received for schedule: ${schedule.scheduleId}`);\n      await notifyScheduleTrigger(schedule, false, \"EMPTY_BODY\");\n      return;\n    }\n\n    // Process attachments if any\n    let attachments: NoteDraftImage[] = [];\n    if (response.attachmentUrls && response.attachmentUrls.length > 0) {\n      try {\n        console.log(\"Preparing attachments\", response.attachmentUrls);\n        attachments = await prepareAttachmentsForNote(response.attachmentUrls);\n      } catch (error) {\n        console.error(\n          `Failed to prepare attachments for schedule ${schedule.scheduleId}:`,\n          error\n        );\n        await notifyScheduleTrigger(\n          schedule,\n          false,\n          \"FAILED_TO_PREPARE_ATTACHMENTS\",\n          String(error)\n        );\n        return;\n      }\n    }\n\n    // Post to Substack\n    try {\n      console.log(\"Posting to Substack\", response.jsonBody);\n      const postResult = await postToSubstack({\n        jsonBody: response.jsonBody,\n        attachmentIds: attachments.map((a) => a.id),\n      });\n      console.log(\"Post result\", postResult);\n      if (postResult.success) {\n        await notifyScheduleTrigger(\n          { ...schedule, substackNoteId: postResult.data?.id },\n          true\n        );\n        console.log(\n          `Successfully posted to Substack for schedule: ${schedule.scheduleId}`\n        );\n      } else {\n        await notifyScheduleTrigger(\n          schedule,\n          false,\n          \"FAILED_TO_POST_TO_SUBSTACK\",\n          postResult.error\n        );\n        console.error(\n          `Failed to post to Substack for schedule ${schedule.scheduleId}:`,\n          postResult.error\n        );\n      }\n    } catch (error) {\n      console.error(\n        `Error posting to Substack for schedule ${schedule.scheduleId}:`,\n        error\n      );\n      await notifyScheduleTrigger(\n        schedule,\n        false,\n        \"FAILED_TO_CREATE_NOTE\",\n        String(error)\n      );\n    }\n  } catch (error) {\n    console.error(\n      `Error handling schedule trigger for ${schedule.scheduleId}:`,\n      error\n    );\n    await notifyScheduleTrigger(\n      schedule,\n      false,\n      \"GENERAL_ERROR\",\n      String(error)\n    );\n  } finally {\n    // update the schedule as not processing\n    freshSchedule.isProcessing = false;\n    await saveSchedules([\n      ...schedules.filter((s) => s.scheduleId !== schedule.scheduleId),\n      freshSchedule,\n    ]);\n  }\n}\n\n/**\n * Notify the API that a schedule has been triggered\n * @param schedule The schedule that was triggered\n * @returns Promise resolving to the API response\n */\nasync function getSchedule(\n  scheduleId: string\n): Promise<ScheduleTriggerResponse | null> {\n  try {\n    console.log(\"Getting schedule\", scheduleId);\n    const schedule = await makeAuthenticatedRequest(\n      getScheduleAPI(scheduleId),\n      {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    if (!schedule || !schedule.success) {\n      console.error(`Error getting schedule ${scheduleId}: ${schedule?.error}`);\n      return null;\n    }\n\n    return schedule.data;\n  } catch (error) {\n    console.error(`Error getting schedule ${scheduleId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Notify the API about the result of a schedule trigger\n * @param schedule The schedule that was triggered\n * @param ok Whether the schedule was successfully handled\n * @param error Error message if not successful\n * @param text Additional error details\n * @returns Promise that resolves when the API has been notified\n */\nasync function notifyScheduleTrigger(\n  schedule: Schedule,\n  ok: boolean,\n  error?: string,\n  text?: string\n): Promise<void> {\n  try {\n    const body: any = {\n      ok,\n      substackNoteId: schedule.substackNoteId,\n    };\n\n    if (!ok && error) {\n      body.error = error;\n      if (text) {\n        body.text = text;\n      }\n    }\n\n    const response = await makeAuthenticatedRequest(\n      getScheduleTriggerAPI(schedule.scheduleId),\n      {\n        method: \"POST\",\n        body: JSON.stringify(body),\n      }\n    );\n\n    if (!response || !response.success) {\n      console.error(\n        `Error notifying API about schedule result: ${response.status} ${response.error}`\n      );\n    }\n  } catch (error) {\n    console.error(`Error notifying API about schedule result:`, error);\n  }\n}\n\n/**\n * Post content to Substack\n * @param body JSON body to post\n * @returns Promise resolving to the result of the post\n */\nasync function postToSubstack(body: {\n  jsonBody: any;\n  attachmentIds: string[];\n}): Promise<PostToSubstackResult> {\n  try {\n    // Convert body to string if it's an object\n    const requestBody: any = {\n      bodyJson: body.jsonBody,\n    };\n    if (body.attachmentIds.length > 0) {\n      requestBody.attachmentIds = body.attachmentIds;\n    }\n    const bodyContent = JSON.stringify(requestBody);\n\n    const response = await fetch(\"https://substack.com/api/v1/comment/feed\", {\n      headers: {\n        \"content-type\": \"application/json\",\n        Referer: \"https://substack.com/home\",\n      },\n      body: bodyContent,\n      method: \"POST\",\n    });\n\n    if (!response.ok) {\n      const responseText = await response.text();\n      console.log(\"Error posting to Substack, response:\", responseText);\n      return {\n        success: false,\n        error: `API returned error: ${response.status} ${responseText}`,\n      };\n    }\n\n    console.log(\"Posting to Substack, response:\", response);\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return {\n      success: false,\n      error: String(error),\n    };\n  }\n}\n","// background.ts\nimport {\n  createSchedule,\n  deleteSchedule,\n  getSchedules,\n  Schedule,\n} from \"../utils/scheduleUtils\";\nimport { handleScheduleTrigger } from \"../utils/scheduleTriggerService\";\nimport { NoteDraftImage, prepareAttachmentsForNote } from \"../utils/imageUtils\";\n\n// Base URL for API requests\nconst API_BASE_URL = \"https://www.writestack.io\";\n\ninterface Response<T> {\n  message: string;\n  action: string;\n  result: T;\n}\n\n// Image upload result interface\ninterface ImageUploadResult {\n  url: string;\n  success: boolean;\n  attachmentId?: string;\n}\n\n// Enhanced logging function\nfunction logScheduledPost(message: string, data?: any) {\n  const timestamp = new Date().toISOString();\n  console.log(`[SCHEDULED POST ${timestamp}] ${message}`, data ? data : \"\");\n}\n\n// Define API handler types\ntype ApiHandlers = {\n  createSubstackPost: (\n    message?: string,\n    scheduleSeconds?: number,\n    autoCloseTab?: boolean\n  ) => Promise<Response<any>>;\n  getSubstackCookies: () => Promise<Response<string>>;\n  setSubstackCookies: () => Promise<Response<any>>;\n  createSchedule: (\n    scheduleId: string,\n    userId: string,\n    timestamp: number\n  ) => Promise<Response<Schedule>>;\n  deleteSchedule: (scheduleId: string) => Promise<Response<boolean>>;\n  getSchedules: () => Promise<Response<Schedule[]>>;\n  uploadImagesToSubstack: (imageUrls: string[]) => Promise<Response<ImageUploadResult[]>>;\n};\n\n// API request handlers\nconst apiHandlers: ApiHandlers = {\n  getSubstackCookies: async (): Promise<Response<string>> => {\n    return new Promise((resolve, reject) => {\n      chrome.cookies.getAll({ domain: \"substack.com\" }, (cookies) => {\n        if (chrome.runtime.lastError) {\n          console.error(\"Error fetching cookies:\", chrome.runtime.lastError);\n          reject(chrome.runtime.lastError.message);\n          return;\n        }\n\n        if (!cookies || cookies.length === 0) {\n          console.warn(\"No Substack cookies found.\");\n          resolve({\n            message: \"No Substack cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        // Only keep relevant cookies\n        const relevantCookieNames = [\"substack.sid\", \"__cf_bm\", \"substack.lli\"];\n        console.log(\"Cookies:\", cookies);\n        const relevantCookies = cookies.filter((c) =>\n          relevantCookieNames.includes(c.name)\n        );\n\n        if (relevantCookies.length === 0) {\n          console.warn(\"No relevant Substack auth cookies found.\");\n          resolve({\n            message: \"No relevant Substack auth cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        const cookieDetails = relevantCookies.map((cookie) => ({\n          name: cookie.name,\n          value: cookie.value,\n          expiresAt: cookie.expirationDate || null,\n          domain: cookie.domain,\n          path: cookie.path,\n          secure: cookie.secure,\n          httpOnly: cookie.httpOnly,\n          sameSite: cookie.sameSite || \"unspecified\",\n        }));\n\n        const result = JSON.stringify(cookieDetails);\n\n        resolve({\n          message: \"Cookies fetched successfully\",\n          action: \"SUBSTACK_COOKIES_FETCHED\",\n          result: result,\n        });\n      });\n    });\n  },\n\n  // Create a post on Substack\n  createSubstackPost: async (bodyJson: any) => {\n    try {\n      const body =\n        typeof bodyJson === \"string\" ? bodyJson : JSON.stringify(bodyJson);\n\n      const response = await fetch(\"https://substack.com/api/v1/comment/feed\", {\n        headers: {\n          \"content-type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n        },\n        body,\n        method: \"POST\",\n      });\n      const data = await response.json();\n      if (!response.ok) {\n        console.log(\"Response:\", response);\n        console.log(\"Data:\", data);\n        return {\n          message: \"Failed to create post\",\n          action: \"SUBSTACK_POST_CREATED\",\n          result: JSON.stringify({ error: \"Failed to create post\" }),\n        };\n      }\n      console.log(\"Response:\", response);\n      console.log(\"Data after post sent:\", data);\n      return {\n        message: \"Post created successfully\",\n        action: \"SUBSTACK_POST_CREATED\",\n        result: JSON.stringify(data),\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logScheduledPost(\"Error creating Substack post\", { error: errorMessage });\n      console.error(\"Error creating Substack post:\", error);\n      throw error;\n    }\n  },\n\n  setSubstackCookies: async () => {\n    const response = await apiHandlers.getSubstackCookies();\n    const parsedCookies = JSON.parse(response.result);\n    console.log(\"Sending to server:\", JSON.stringify(parsedCookies));\n\n    try {\n      const cookiesResponse = await fetch(`${API_BASE_URL}/api/user/cookies`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(parsedCookies),\n      });\n      if (!cookiesResponse.ok) {\n        console.error(\"Failed to send cookies to server\");\n        return response;\n      }\n      const data = await cookiesResponse.json();\n      console.log(\"Cookies sent to server successfully\" + data);\n      return response;\n    } catch (error) {\n      console.error(\"Error sending cookies to server:\", error);\n      return response;\n    }\n  },\n\n  // Create a new schedule\n  createSchedule: async (\n    scheduleId: string,\n    userId: string,\n    timestamp: number\n  ): Promise<Response<Schedule>> => {\n    try {\n      // Create schedule in extension storage\n      console.log(\"Creating schedule\", scheduleId, userId, timestamp);\n      const schedule = await createSchedule(scheduleId, userId, timestamp);\n      console.log(\"Schedule created successfully\", schedule);\n      return {\n        message: \"Schedule created successfully\",\n        action: \"SCHEDULE_CREATED\",\n        result: schedule,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      console.error(\"Error creating schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  deleteSchedule: async (scheduleId: string): Promise<Response<boolean>> => {\n    try {\n      // Delete schedule from extension storage\n      const result = await deleteSchedule(scheduleId);\n      return {\n        message: result\n          ? \"Schedule deleted successfully\"\n          : \"Schedule not found\",\n        action: \"SCHEDULE_DELETED\",\n        result,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      console.error(\"Error deleting schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Get all schedules\n  getSchedules: async (): Promise<Response<Schedule[]>> => {\n    try {\n      // Get schedules from extension storage\n      const schedules = await getSchedules();\n      return {\n        message: `Found ${schedules.length} schedules`,\n        action: \"SCHEDULES_FETCHED\",\n        result: schedules,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      console.error(\"Error getting schedules:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Upload multiple images to Substack\n  uploadImagesToSubstack: async (\n    imageUrls: string[]\n  ): Promise<Response<ImageUploadResult[]>> => {\n    console.log(\"Uploading images to Substack:\", imageUrls);\n\n    if (!imageUrls || !imageUrls.length) {\n      return {\n        message: \"No images to upload\",\n        action: \"IMAGES_UPLOADED\",\n        result: [],\n      };\n    }\n\n    // Process each image URL, tracking results\n    const results: ImageUploadResult[] = [];\n\n    try {\n      // Use prepareAttachmentsForNote to process all images\n      const attachments = await prepareAttachmentsForNote(imageUrls);\n\n      // Create result entries for successful uploads\n      const successfulUploads = new Map<string, NoteDraftImage>();\n      attachments.forEach((attachment) => {\n        successfulUploads.set(attachment.url, attachment);\n      });\n\n      // Create result for each original URL\n      for (const imageUrl of imageUrls) {\n        const attachment = successfulUploads.get(imageUrl);\n\n        if (attachment) {\n          results.push({\n            url: imageUrl,\n            success: true,\n            attachmentId: attachment.id,\n          });\n        } else {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Successfully uploaded ${attachments.length} of ${imageUrls.length} images`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      console.error(\"Error uploading images to Substack:\", errorMessage);\n\n      // For any remaining URLs not in results, add failed entries\n      const processedUrls = new Set(results.map((r) => r.url));\n\n      for (const imageUrl of imageUrls) {\n        if (!processedUrls.has(imageUrl)) {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Error uploading images: ${errorMessage}`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    }\n  },\n};\n\n// Define message types\ninterface ApiRequestMessage {\n  type: \"API_REQUEST\" | \"PING\";\n  action: keyof ApiHandlers;\n  params?: unknown[];\n}\n\ninterface GenerateIdeasMessage {\n  type: \"GENERATE_IDEAS\";\n}\n\ntype ChromeMessage = ApiRequestMessage | GenerateIdeasMessage;\n\n// Helper function to safely call API handlers with dynamic parameters\nfunction callApiHandler(\n  action: keyof ApiHandlers,\n  params: unknown[] = []\n): Promise<any> {\n  switch (action) {\n    case \"getSubstackCookies\":\n      return apiHandlers.getSubstackCookies();\n    case \"setSubstackCookies\":\n      return apiHandlers.setSubstackCookies();\n    case \"createSubstackPost\":\n      return apiHandlers.createSubstackPost(\n        params[0] as string | undefined,\n        params[1] as number | undefined,\n        params[2] as boolean | undefined\n      );\n    case \"createSchedule\":\n      return apiHandlers.createSchedule(\n        params[0] as string,\n        params[1] as string,\n        params[2] as number\n      );\n    case \"deleteSchedule\":\n      return apiHandlers.deleteSchedule(params[0] as string);\n    case \"getSchedules\":\n      return apiHandlers.getSchedules();\n    case \"uploadImagesToSubstack\":\n      return apiHandlers.uploadImagesToSubstack(params[0] as string[]);\n    default:\n      return Promise.reject(new Error(`Unknown action: ${action}`));\n  }\n}\n\nlet isSending = false;\n\n// Set up alarm listener for schedule triggers\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n  console.log(`Alarm triggered: ${alarm.name}`);\n\n  // Check if this is a schedule alarm\n  const schedules = await getSchedules();\n  const schedule = schedules.find((s) => s.scheduleId === alarm.name);\n\n  if (schedule) {\n    console.log(`Processing schedule: ${schedule.scheduleId}`);\n    try {\n      await handleScheduleTrigger(schedule);\n\n      // Delete the schedule after processing\n      await deleteSchedule(schedule.scheduleId);\n    } catch (error) {\n      console.error(`Error handling schedule ${schedule.scheduleId}:`, error);\n    }\n  }\n});\n\nchrome.runtime.onMessageExternal.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    console.log(\n      \"Background script received external message:\",\n      request,\n      \"from:\",\n      sender?.url,\n      \"Type: \",\n      request?.type\n    );\n\n    // Handle PING message - respond immediately without async\n    if (request?.type === \"PING\") {\n      console.log(\"Received external PING, responding immediately\");\n      const version = chrome.runtime.getManifest().version;\n      console.log(\"Version:\", version);\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        version,\n        message: \"Extension is active\",\n        source: \"external\",\n      });\n      return false; // No async response needed\n    }\n\n    // Handle API requests\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      console.log(\"Received API request:\", action, params);\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            console.error(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n        return true; // Will respond asynchronously\n      }\n    }\n\n    return false;\n  }\n);\n\nchrome.runtime.onMessage.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    console.log(\"Background got internal message:\", request);\n\n    if (request?.type === \"PING\") {\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        message: \"Extension is active\",\n        source: \"internal\",\n      });\n      return false;\n    }\n\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      console.log(\"API request:\", action, params);\n\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            console.error(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n);\n\n// Initialize the extension\nasync function initializeExtension() {\n  console.log(\"Initializing extension...\");\n\n  // Check for any pending schedules\n  const schedules = await getSchedules();\n  if (schedules.length > 0) {\n    console.log(`Found ${schedules.length} schedules`);\n\n    // Process any schedules that should have already been triggered\n    const now = Date.now();\n    // const pastSchedules = schedules.filter((s) => s.timestamp <= now);\n\n    // if (pastSchedules.length > 0) {\n    //   console.log(`Processing ${pastSchedules.length} past schedules`);\n\n    //   for (const schedule of pastSchedules) {\n    //     try {\n    //       await handleScheduleTrigger(schedule);\n    //       await deleteSchedule(schedule.scheduleId);\n    //     } catch (error) {\n    //       console.error(\n    //         `Error handling past schedule ${schedule.scheduleId}:`,\n    //         error\n    //       );\n    //     }\n    //   }\n    // }\n\n    // Set up alarms for future schedules\n    const futureSchedules = schedules.filter((s) => s.timestamp > now);\n    if (futureSchedules.length > 0) {\n      console.log(\n        `Setting up alarms for ${futureSchedules.length} future schedules`\n      );\n\n      for (const schedule of futureSchedules) {\n        try {\n          chrome.alarms.create(schedule.scheduleId, {\n            when: schedule.timestamp,\n          });\n          console.log(\n            `Alarm created for schedule ${schedule.scheduleId} at ${new Date(\n              schedule.timestamp\n            ).toISOString()}`\n          );\n        } catch (error) {\n          console.error(\n            `Error creating alarm for schedule ${schedule.scheduleId}:`,\n            error\n          );\n        }\n      }\n    }\n  }\n}\n\n// Run initialization\ninitializeExtension().catch((error) => {\n  console.error(\"Error initializing extension:\", error);\n});\n"],"names":["SCHEDULES_STORAGE_KEY","createSchedule","scheduleId","userId","timestamp","existingSchedules","getSchedules","schedule","newSchedule","updatedSchedules","saveSchedules","createAlarmForSchedule","deleteSchedule","error","schedules","a","API_BASE_URL","makeAuthenticatedRequest","endpoint","options","baseUrl","url","response","text","json","downloadImage","responseText","arrayBuffer","uploadImageSubstack","image","dataUri","arrayBufferToBase64","uploadImageResponse","data","getImageResponse","imageData","noteDraftImage","buffer","binary","bytes","len","i","prepareAttachmentsForNote","urls","maxAttachments","attachmentsToUpload","attachments","substackImage","getScheduleTriggerAPI","getScheduleAPI","handleScheduleTrigger","_a","freshSchedule","s","getSchedule","notifyScheduleTrigger","postResult","postToSubstack","ok","body","requestBody","bodyContent","logScheduledPost","message","apiHandlers","resolve","reject","cookies","relevantCookieNames","relevantCookies","cookieDetails","cookie","result","bodyJson","errorMessage","parsedCookies","cookiesResponse","imageUrls","results","successfulUploads","attachment","imageUrl","processedUrls","r","callApiHandler","action","params","alarm","request","sender","sendResponse","version","initializeExtension","now","futureSchedules"],"mappings":"AAWA,MAAMA,EAAwB,uBASR,eAAAC,EACpBC,EACAC,EACAC,EACmB,CAEnB,GAAI,CAACF,GAAc,CAACC,GAAU,CAACC,EACvB,MAAA,IAAI,MAAM,6BAA6B,EAIzC,MAAAC,EAAoB,MAAMC,IAMhC,GAHuBD,EAAkB,KACtCE,GAAaA,EAAS,aAAeL,CAAA,EAGhC,MAAA,IAAI,MAAM,oBAAoBA,kBAA2B,EAIjE,MAAMM,EAAwB,CAC5B,WAAAN,EACA,OAAAC,EACA,UAAAC,CAAA,EAIIK,EAAmB,CAAC,GAAGJ,EAAmBG,CAAW,EAC3D,aAAME,EAAcD,CAAgB,EAGpC,MAAME,EAAuBH,CAAW,EAEhC,QAAA,IACN,qBAAqBN,QAAiB,IAAI,KAAKE,CAAS,EAAE,YAAY,GAAA,EAEjEI,CACT,CAOA,eAAsBI,EAAeV,EAAsC,CAEnE,MAAAG,EAAoB,MAAMC,IAG1BG,EAAmBJ,EAAkB,OACxCE,GAAaA,EAAS,aAAeL,CAAA,EAIpC,GAAAO,EAAiB,SAAWJ,EAAkB,OACzC,MAAA,GAIL,GAAA,CACI,MAAA,OAAO,OAAO,MAAMH,CAAU,QAE7BW,GACC,QAAA,MAAM,sCAAsCX,KAAeW,CAAK,CAC1E,CAGA,aAAMH,EAAcD,CAAgB,EAC5B,QAAA,IAAI,qBAAqBP,GAAY,EACtC,EACT,CAMA,eAAsBI,GAAoC,CACpD,GAAA,CAEK,OADQ,MAAM,OAAO,QAAQ,MAAM,IAAIN,CAAqB,GACrDA,IAA0B,SACjCa,GACC,eAAA,MAAM,2BAA4BA,CAAK,EACxC,EACT,CACF,CAOA,eAAsBH,EAAcI,EAAsC,CACpE,GAAA,CACM,QAAA,IAAI,mBAAoBA,CAAS,EACnC,MAAA,OAAO,QAAQ,MAAM,IAAI,CAAE,CAACd,GAAwBc,EAAW,QAC9DD,GACC,cAAA,MAAM,4BAA6BA,CAAK,EAC1C,IAAI,MAAM,0BAA0B,CAC5C,CACF,CA6BA,eAAeF,EAAuBJ,EAAmC,CACnE,GAAA,CAIE,GAFI,QAAA,IAAI,8BAA+BA,EAAS,UAAU,GAC5C,MAAM,OAAO,OAAO,OAAO,GAC/B,KAAMQ,GAAMA,EAAE,OAASR,EAAS,UAAU,EAAG,CACjD,QAAA,IAAI,oCAAqCA,EAAS,UAAU,EACpE,MACF,CACO,OAAA,OAAO,OAAOA,EAAS,WAAY,CACxC,KAAMA,EAAS,SAAA,CAChB,EAEO,QAAA,IACN,8BAA8BA,EAAS,iBAAiB,IAAI,KAC1DA,EAAS,SAAA,EACT,YAAY,GAAA,QAETM,GACC,cAAA,MACN,uCAAuCN,EAAS,cAChDM,CAAA,EAEI,IAAI,MAAM,qCAAqC,CACvD,CACF,CC/KA,MAAMG,EAAe,4BAGrB,eAAsBC,EACpBC,EACAC,EAAuB,CAAA,EACvBC,EACA,CACI,GAAA,CACE,IAAAC,EAAM,GAAGD,GAAWJ,KAAgBE,IAElCG,EAAAA,EAAI,QAAQ,OAAQ,IAAI,EACtB,QAAA,IAAI,iBAAkBA,EAAKF,CAAO,EACpC,MAAAG,EAAW,MAAM,MAAMD,EAAK,CAChC,GAAGF,EACH,YAAa,UACb,QAAS,CACP,eAAgB,mBAChB,GAAGA,EAAQ,OACb,CAAA,CACD,EAEG,GAAA,CAACG,EAAS,GAAI,CACV,MAAAC,EAAO,MAAMD,EAAS,OAC5B,eAAQ,IAAI,iBAAkBA,EAAS,OAAQC,CAAI,EAC5C,CACL,QAAS,GACT,MAAOA,EACP,OAAQD,EAAS,MAAA,CAErB,CAEM,MAAAE,EAAO,MAAMF,EAAS,OACpB,eAAA,IAAI,gBAAiBE,CAAI,EAE1B,CACL,QAAS,GACT,KAAMA,EACN,OAAQF,EAAS,MAAA,QAEZT,GACC,eAAA,MAAM,iBAAkBA,CAAK,EAC9B,CACL,QAAS,GACT,MAAOA,EAAM,QACb,OAAQ,GAAA,CAEZ,CACF,CC1BA,eAAsBY,EAAcJ,EAAyC,CACvE,GAAA,CACI,MAAAC,EAAW,MAAM,MAAMD,CAAG,EAC5B,GAAA,CAACC,EAAS,GAAI,CACV,MAAAI,EAAe,MAAMJ,EAAS,OAC5B,eAAA,MACN,8BAA8BD,kBAAoBC,EAAS,qBAAqBI,GAAA,EAE3E,IACT,CAEM,MAAAC,EAAc,MAAML,EAAS,cAC5B,OAAA,IAAI,WAAWK,CAAW,QAC1Bd,GACC,eAAA,MAAM,gCAAgCQ,KAAQR,CAAK,EACpD,IACT,CACF,CASA,eAAsBe,EACpBC,EACyB,CACzB,GAAI,CAACA,EACG,MAAA,IAAI,MAAM,oBAAoB,EAGlC,GAAA,CAGF,MAAMC,EAAU,yBADDC,EAAoBF,CAAK,IAGhC,QAAA,IAAI,8BAA+BC,CAAO,EAGlD,MAAME,EAAsB,MAAM,MAChC,oCACA,CACE,QAAS,CACP,eAAgB,mBAChB,QAAS,4BACT,kBAAmB,iCACrB,EACA,KAAM,KAAK,UAAU,CAAE,MAAOF,EAAS,EACvC,OAAQ,MACV,CAAA,EAGE,GAAA,CAACE,EAAoB,GAAI,CACrB,MAAAN,EAAe,MAAMM,EAAoB,OACvC,cAAA,MAAM,uCAAuCN,GAAc,EAC7D,IAAI,MAAM,oCAAoC,CACtD,CAEM,MAAAO,EAAO,MAAMD,EAAoB,OAGjCE,EAAmB,MAAM,MAC7B,iDACA,CACE,QAAS,CACP,eAAgB,mBAChB,QAAS,4BACT,kBAAmB,iCACrB,EACA,OAAQ,OACR,KAAM,KAAK,UAAU,CAAE,KAAM,QAAS,IAAKD,EAAK,IAAK,CACvD,CAAA,EAGE,GAAA,CAACC,EAAiB,GAAI,CAClB,MAAAR,EAAe,MAAMQ,EAAiB,OACpC,cAAA,MAAM,sCAAsCR,GAAc,EAC5D,IAAI,MAAM,mCAAmC,CACrD,CAEM,MAAAS,EAAmC,MAAMD,EAAiB,OAG1DE,EAAiC,CACrC,GAAID,EAAU,GACd,IAAKA,EAAU,QAAA,EAGT,eAAA,IAAI,+BAA+BC,EAAe,IAAI,EACvDA,QACAvB,GACC,cAAA,MAAM,qCAAsCA,CAAK,EACnD,IAAI,MAAM,oCAAoC,CACtD,CACF,CAOA,SAASkB,EAAoBM,EAA4B,CACvD,IAAIC,EAAS,GACP,MAAAC,EAAQ,IAAI,WAAWF,CAAM,EAC7BG,EAAMD,EAAM,WAClB,QAASE,EAAI,EAAGA,EAAID,EAAKC,IACbH,GAAA,OAAO,aAAaC,EAAME,EAAE,EAExC,OAAO,KAAKH,CAAM,CACpB,CASA,eAAsBI,EACpBC,EAC2B,CAC3B,GAAI,CAACA,GAAQA,EAAK,SAAW,EAC3B,MAAO,GAGT,MAAMC,EAAiB,EACjBC,EAAsBF,EAAK,MAAM,EAAGC,CAAc,EAClDE,EAAgC,CAAA,EAE9B,QAAA,IAAI,wBAAyBD,CAAmB,EAExD,UAAWxB,KAAOwB,EACZ,GAAA,CAEI,MAAAR,EAAS,MAAMZ,EAAcJ,CAAG,EACtC,GAAI,CAACgB,EAAQ,CACH,QAAA,MAAM,iCAAiChB,GAAK,EACpD,QACF,CAEQ,QAAA,IAAI,0BAA2BgB,EAAO,MAAM,EAG9C,MAAAU,EAAgB,MAAMnB,EAAoBS,CAAM,EACtDS,EAAY,KAAKC,CAAa,QACvBlC,GACC,QAAA,MAAM,oCAAoCQ,KAAQR,CAAK,CACjE,CAGK,OAAAiC,CACT,CC1KA,MAAME,EAAyB9C,GAC7B,6BAA6BA,cACzB+C,EAAkB/C,GACtB,6BAA6BA,IAqB/B,eAAsBgD,EAAsB3C,EAAmC,CHlB/E,IAAA4C,EGmBU,QAAA,IAAI,gCAAgC5C,EAAS,YAAY,EAE3D,MAAAO,EAAY,MAAMR,IAClB8C,EAAgBtC,EAAU,KAC7B,GAAM,EAAE,aAAeP,EAAS,UAAA,EAE/B,GAAA,CAAC6C,GAAiBA,EAAc,aAAc,CACxC,QAAA,KAAK,wCAAwC7C,EAAS,YAAY,EAC1E,MACF,CACI,GAAA,CAEF6C,EAAc,aAAe,GAC7B,MAAM1C,EAAc,CAClB,GAAGI,EAAU,OAAQuC,GAAMA,EAAE,aAAe9C,EAAS,UAAU,EAC/D6C,CAAA,CACD,EAGD,MAAM9B,EAAW,MAAMgC,EAAY/C,EAAS,UAAU,EAGtD,GAFQ,QAAA,IAAI,uBAAwBe,CAAQ,EAExC,CAACA,GAAY,CAACA,EAAS,SAAU,CAC3B,QAAA,MAAM,qCAAqCf,EAAS,YAAY,EAClE,MAAAgD,EAAsBhD,EAAU,GAAO,YAAY,EACzD,MACF,CAGA,IAAIuC,EAAgC,CAAA,EACpC,GAAIxB,EAAS,gBAAkBA,EAAS,eAAe,OAAS,EAC1D,GAAA,CACM,QAAA,IAAI,wBAAyBA,EAAS,cAAc,EAC9CwB,EAAA,MAAMJ,EAA0BpB,EAAS,cAAc,QAC9DT,GACC,QAAA,MACN,8CAA8CN,EAAS,cACvDM,CAAA,EAEI,MAAA0C,EACJhD,EACA,GACA,gCACA,OAAOM,CAAK,CAAA,EAEd,MACF,CAIE,GAAA,CACM,QAAA,IAAI,sBAAuBS,EAAS,QAAQ,EAC9C,MAAAkC,EAAa,MAAMC,EAAe,CACtC,SAAUnC,EAAS,SACnB,cAAewB,EAAY,IAAK/B,GAAMA,EAAE,EAAE,CAAA,CAC3C,EACO,QAAA,IAAI,cAAeyC,CAAU,EACjCA,EAAW,SACP,MAAAD,EACJ,CAAE,GAAGhD,EAAU,gBAAgB4C,EAAAK,EAAW,OAAX,YAAAL,EAAiB,EAAG,EACnD,EAAA,EAEM,QAAA,IACN,iDAAiD5C,EAAS,YAAA,IAGtD,MAAAgD,EACJhD,EACA,GACA,6BACAiD,EAAW,KAAA,EAEL,QAAA,MACN,2CAA2CjD,EAAS,cACpDiD,EAAW,KAAA,SAGR3C,GACC,QAAA,MACN,0CAA0CN,EAAS,cACnDM,CAAA,EAEI,MAAA0C,EACJhD,EACA,GACA,wBACA,OAAOM,CAAK,CAAA,CAEhB,QACOA,GACC,QAAA,MACN,uCAAuCN,EAAS,cAChDM,CAAA,EAEI,MAAA0C,EACJhD,EACA,GACA,gBACA,OAAOM,CAAK,CAAA,CACd,QACA,CAEAuC,EAAc,aAAe,GAC7B,MAAM1C,EAAc,CAClB,GAAGI,EAAU,OAAQ,GAAM,EAAE,aAAeP,EAAS,UAAU,EAC/D6C,CAAA,CACD,CACH,CACF,CAOA,eAAeE,EACbpD,EACyC,CACrC,GAAA,CACM,QAAA,IAAI,mBAAoBA,CAAU,EAC1C,MAAMK,EAAW,MAAMU,EACrBgC,EAAe/C,CAAU,EACzB,CACE,OAAQ,MACR,QAAS,CACP,eAAgB,kBAClB,CACF,CAAA,EAGF,MAAI,CAACK,GAAY,CAACA,EAAS,SACzB,QAAQ,MAAM,0BAA0BL,MAAeK,GAAA,YAAAA,EAAU,OAAO,EACjE,MAGFA,EAAS,WACTM,GACC,cAAA,MAAM,0BAA0BX,KAAeW,CAAK,EACtDA,CACR,CACF,CAUA,eAAe0C,EACbhD,EACAmD,EACA7C,EACAU,EACe,CACX,GAAA,CACF,MAAMoC,EAAY,CAChB,GAAAD,EACA,eAAgBnD,EAAS,cAAA,EAGvB,CAACmD,GAAM7C,IACT8C,EAAK,MAAQ9C,EACTU,IACFoC,EAAK,KAAOpC,IAIhB,MAAMD,EAAW,MAAML,EACrB+B,EAAsBzC,EAAS,UAAU,EACzC,CACE,OAAQ,OACR,KAAM,KAAK,UAAUoD,CAAI,CAC3B,CAAA,GAGE,CAACrC,GAAY,CAACA,EAAS,UACjB,QAAA,MACN,8CAA8CA,EAAS,UAAUA,EAAS,OAAA,QAGvET,GACC,QAAA,MAAM,6CAA8CA,CAAK,CACnE,CACF,CAOA,eAAe4C,EAAeE,EAGI,CAC5B,GAAA,CAEF,MAAMC,EAAmB,CACvB,SAAUD,EAAK,QAAA,EAEbA,EAAK,cAAc,OAAS,IAC9BC,EAAY,cAAgBD,EAAK,eAE7B,MAAAE,EAAc,KAAK,UAAUD,CAAW,EAExCtC,EAAW,MAAM,MAAM,2CAA4C,CACvE,QAAS,CACP,eAAgB,mBAChB,QAAS,2BACX,EACA,KAAMuC,EACN,OAAQ,MAAA,CACT,EAEG,GAAA,CAACvC,EAAS,GAAI,CACV,MAAAI,EAAe,MAAMJ,EAAS,OAC5B,eAAA,IAAI,uCAAwCI,CAAY,EACzD,CACL,QAAS,GACT,MAAO,uBAAuBJ,EAAS,UAAUI,GAAA,CAErD,CAEQ,QAAA,IAAI,iCAAkCJ,CAAQ,EAChD,MAAAW,EAAO,MAAMX,EAAS,OACrB,MAAA,CAAE,QAAS,GAAM,KAAAW,SACjBpB,GACA,MAAA,CACL,QAAS,GACT,MAAO,OAAOA,CAAK,CAAA,CAEvB,CACF,CC5PA,MAAMG,EAAe,4BAgBrB,SAAS8C,EAAiBC,EAAiB9B,EAAY,CACrD,MAAM7B,EAAY,IAAI,KAAK,EAAE,YAAY,EACzC,QAAQ,IAAI,mBAAmBA,MAAc2D,IAAW9B,GAAc,EAAE,CAC1E,CAsBA,MAAM+B,EAA2B,CAC/B,mBAAoB,SACX,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,OAAO,QAAQ,OAAO,CAAE,OAAQ,cAAe,EAAIC,GAAY,CACzD,GAAA,OAAO,QAAQ,UAAW,CAC5B,QAAQ,MAAM,0BAA2B,OAAO,QAAQ,SAAS,EAC1DD,EAAA,OAAO,QAAQ,UAAU,OAAO,EACvC,MACF,CAEA,GAAI,CAACC,GAAWA,EAAQ,SAAW,EAAG,CACpC,QAAQ,KAAK,4BAA4B,EACjCF,EAAA,CACN,QAAS,6BACT,OAAQ,2BACR,OAAQ,EAAA,CACT,EACD,MACF,CAGA,MAAMG,EAAsB,CAAC,eAAgB,UAAW,cAAc,EAC9D,QAAA,IAAI,WAAYD,CAAO,EAC/B,MAAME,EAAkBF,EAAQ,OAAQ,GACtCC,EAAoB,SAAS,EAAE,IAAI,CAAA,EAGjC,GAAAC,EAAgB,SAAW,EAAG,CAChC,QAAQ,KAAK,0CAA0C,EAC/CJ,EAAA,CACN,QAAS,2CACT,OAAQ,2BACR,OAAQ,EAAA,CACT,EACD,MACF,CAEA,MAAMK,EAAgBD,EAAgB,IAAKE,IAAY,CACrD,KAAMA,EAAO,KACb,MAAOA,EAAO,MACd,UAAWA,EAAO,gBAAkB,KACpC,OAAQA,EAAO,OACf,KAAMA,EAAO,KACb,OAAQA,EAAO,OACf,SAAUA,EAAO,SACjB,SAAUA,EAAO,UAAY,aAC7B,EAAA,EAEIC,EAAS,KAAK,UAAUF,CAAa,EAEnCL,EAAA,CACN,QAAS,+BACT,OAAQ,2BACR,OAAAO,CAAA,CACD,CAAA,CACF,CAAA,CACF,EAIH,mBAAoB,MAAOC,GAAkB,CACvC,GAAA,CACF,MAAMd,EACJ,OAAOc,GAAa,SAAWA,EAAW,KAAK,UAAUA,CAAQ,EAE7DnD,EAAW,MAAM,MAAM,2CAA4C,CACvE,QAAS,CACP,eAAgB,mBAChB,QAAS,2BACX,EACA,KAAAqC,EACA,OAAQ,MAAA,CACT,EACK1B,EAAO,MAAMX,EAAS,OACxB,OAACA,EAAS,IASN,QAAA,IAAI,YAAaA,CAAQ,EACzB,QAAA,IAAI,wBAAyBW,CAAI,EAClC,CACL,QAAS,4BACT,OAAQ,wBACR,OAAQ,KAAK,UAAUA,CAAI,CAAA,IAbnB,QAAA,IAAI,YAAaX,CAAQ,EACzB,QAAA,IAAI,QAASW,CAAI,EAClB,CACL,QAAS,wBACT,OAAQ,wBACR,OAAQ,KAAK,UAAU,CAAE,MAAO,wBAAyB,CAAA,SAUtDpB,GACP,MAAM6D,EACJ7D,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EACvD,MAAAiD,EAAiB,+BAAgC,CAAE,MAAOY,CAAc,CAAA,EAChE,QAAA,MAAM,gCAAiC7D,CAAK,EAC9CA,CACR,CACF,EAEA,mBAAoB,SAAY,CACxB,MAAAS,EAAW,MAAM0C,EAAY,qBAC7BW,EAAgB,KAAK,MAAMrD,EAAS,MAAM,EAChD,QAAQ,IAAI,qBAAsB,KAAK,UAAUqD,CAAa,CAAC,EAE3D,GAAA,CACF,MAAMC,EAAkB,MAAM,MAAM,GAAG5D,qBAAiC,CACtE,OAAQ,OACR,QAAS,CACP,eAAgB,kBAClB,EACA,KAAM,KAAK,UAAU2D,CAAa,CAAA,CACnC,EACG,GAAA,CAACC,EAAgB,GACnB,eAAQ,MAAM,kCAAkC,EACzCtD,EAEH,MAAAW,EAAO,MAAM2C,EAAgB,OAC3B,eAAA,IAAI,sCAAwC3C,CAAI,EACjDX,QACAT,GACC,eAAA,MAAM,mCAAoCA,CAAK,EAChDS,CACT,CACF,EAGA,eAAgB,MACdpB,EACAC,EACAC,IACgC,CAC5B,GAAA,CAEF,QAAQ,IAAI,oBAAqBF,EAAYC,EAAQC,CAAS,EAC9D,MAAMG,EAAW,MAAMN,EAAeC,EAAYC,EAAQC,CAAS,EAC3D,eAAA,IAAI,gCAAiCG,CAAQ,EAC9C,CACL,QAAS,gCACT,OAAQ,mBACR,OAAQA,CAAA,QAEHM,GACP,MAAM6D,EACJ7D,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC/C,cAAA,MAAM,2BAA4B6D,CAAY,EAChD7D,CACR,CACF,EAEA,eAAgB,MAAOX,GAAmD,CACpE,GAAA,CAEI,MAAAsE,EAAS,MAAM5D,EAAeV,CAAU,EACvC,MAAA,CACL,QAASsE,EACL,gCACA,qBACJ,OAAQ,mBACR,OAAAA,CAAA,QAEK3D,GACP,MAAM6D,EACJ7D,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC/C,cAAA,MAAM,2BAA4B6D,CAAY,EAChD7D,CACR,CACF,EAGA,aAAc,SAA2C,CACnD,GAAA,CAEI,MAAAC,EAAY,MAAMR,IACjB,MAAA,CACL,QAAS,SAASQ,EAAU,mBAC5B,OAAQ,oBACR,OAAQA,CAAA,QAEHD,GACP,MAAM6D,EACJ7D,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC/C,cAAA,MAAM,2BAA4B6D,CAAY,EAChD7D,CACR,CACF,EAGA,uBAAwB,MACtBgE,GAC2C,CAG3C,GAFQ,QAAA,IAAI,gCAAiCA,CAAS,EAElD,CAACA,GAAa,CAACA,EAAU,OACpB,MAAA,CACL,QAAS,sBACT,OAAQ,kBACR,OAAQ,CAAC,CAAA,EAKb,MAAMC,EAA+B,CAAA,EAEjC,GAAA,CAEI,MAAAhC,EAAc,MAAMJ,EAA0BmC,CAAS,EAGvDE,MAAwB,IAClBjC,EAAA,QAASkC,GAAe,CAChBD,EAAA,IAAIC,EAAW,IAAKA,CAAU,CAAA,CACjD,EAGD,UAAWC,KAAYJ,EAAW,CAC1B,MAAAG,EAAaD,EAAkB,IAAIE,CAAQ,EAE7CD,EACFF,EAAQ,KAAK,CACX,IAAKG,EACL,QAAS,GACT,aAAcD,EAAW,EAAA,CAC1B,EAEDF,EAAQ,KAAK,CACX,IAAKG,EACL,QAAS,EAAA,CACV,CAEL,CAEO,MAAA,CACL,QAAS,yBAAyBnC,EAAY,aAAa+B,EAAU,gBACrE,OAAQ,kBACR,OAAQC,CAAA,QAEHjE,GACP,MAAM6D,EACJ7D,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC/C,QAAA,MAAM,sCAAuC6D,CAAY,EAG3D,MAAAQ,EAAgB,IAAI,IAAIJ,EAAQ,IAAKK,GAAMA,EAAE,GAAG,CAAC,EAEvD,UAAWF,KAAYJ,EAChBK,EAAc,IAAID,CAAQ,GAC7BH,EAAQ,KAAK,CACX,IAAKG,EACL,QAAS,EAAA,CACV,EAIE,MAAA,CACL,QAAS,2BAA2BP,IACpC,OAAQ,kBACR,OAAQI,CAAA,CAEZ,CACF,CACF,EAgBA,SAASM,EACPC,EACAC,EAAoB,GACN,CACN,OAAAD,OACD,qBACH,OAAOrB,EAAY,yBAChB,qBACH,OAAOA,EAAY,yBAChB,qBACH,OAAOA,EAAY,mBACjBsB,EAAO,GACPA,EAAO,GACPA,EAAO,EAAA,MAEN,iBACH,OAAOtB,EAAY,eACjBsB,EAAO,GACPA,EAAO,GACPA,EAAO,EAAA,MAEN,iBACI,OAAAtB,EAAY,eAAesB,EAAO,EAAY,MAClD,eACH,OAAOtB,EAAY,mBAChB,yBACI,OAAAA,EAAY,uBAAuBsB,EAAO,EAAc,UAE/D,OAAO,QAAQ,OAAO,IAAI,MAAM,mBAAmBD,GAAQ,CAAC,EAElE,CAKA,OAAO,OAAO,QAAQ,YAAY,MAAOE,GAAU,CACzC,QAAA,IAAI,oBAAoBA,EAAM,MAAM,EAItC,MAAAhF,GADY,MAAMD,KACG,KAAM+C,GAAMA,EAAE,aAAekC,EAAM,IAAI,EAElE,GAAIhF,EAAU,CACJ,QAAA,IAAI,wBAAwBA,EAAS,YAAY,EACrD,GAAA,CACF,MAAM2C,EAAsB3C,CAAQ,EAG9B,MAAAK,EAAeL,EAAS,UAAU,QACjCM,GACP,QAAQ,MAAM,2BAA2BN,EAAS,cAAeM,CAAK,CACxE,CACF,CACF,CAAC,EAED,OAAO,QAAQ,kBAAkB,YAC/B,CAAC2E,EAAwBC,EAAQC,IAAiB,CAW5C,GAVI,QAAA,IACN,+CACAF,EACA,QACAC,GAAA,YAAAA,EAAQ,IACR,SACAD,GAAA,YAAAA,EAAS,IAAA,GAIPA,GAAA,YAAAA,EAAS,QAAS,OAAQ,CAC5B,QAAQ,IAAI,gDAAgD,EAC5D,MAAMG,EAAU,OAAO,QAAQ,YAAA,EAAc,QACrC,eAAA,IAAI,WAAYA,CAAO,EAClBD,EAAA,CACX,QAAS,GACT,UAAW,KAAK,IAAI,EACpB,QAAAC,EACA,QAAS,sBACT,OAAQ,UAAA,CACT,EACM,EACT,CAGI,IAAAH,GAAA,YAAAA,EAAS,QAAS,cAAe,CAC7B,KAAA,CAAE,OAAAH,EAAQ,OAAAC,CAAW,EAAAE,EAE3B,GADQ,QAAA,IAAI,wBAAyBH,EAAQC,CAAM,EAC/CD,EACF,OAAAD,EAAeC,EAAQC,CAAM,EAC1B,KAAMrD,GAAc,CACnByD,EAAa,CAAE,QAAS,GAAM,KAAAzD,CAAM,CAAA,CAAA,CACrC,EACA,MAAOpB,GAAiB,CACf,QAAA,MAAM,yBAAyBwE,MAAYxE,CAAK,EACxD6E,EAAa,CAAE,QAAS,GAAO,MAAO7E,EAAM,QAAS,CAAA,CACtD,EACI,EAEX,CAEO,MAAA,EACT,CACF,EAEA,OAAO,QAAQ,UAAU,YACvB,CAAC2E,EAAwBC,EAAQC,IAAiB,CAG5C,GAFI,QAAA,IAAI,mCAAoCF,CAAO,GAEnDA,GAAA,YAAAA,EAAS,QAAS,OACP,OAAAE,EAAA,CACX,QAAS,GACT,UAAW,KAAK,IAAI,EACpB,QAAS,sBACT,OAAQ,UAAA,CACT,EACM,GAGL,IAAAF,GAAA,YAAAA,EAAS,QAAS,cAAe,CAC7B,KAAA,CAAE,OAAAH,EAAQ,OAAAC,CAAW,EAAAE,EAG3B,GAFQ,QAAA,IAAI,eAAgBH,EAAQC,CAAM,EAEtCD,EACF,OAAAD,EAAeC,EAAQC,CAAM,EAC1B,KAAMrD,GAAc,CACnByD,EAAa,CAAE,QAAS,GAAM,KAAAzD,CAAM,CAAA,CAAA,CACrC,EACA,MAAOpB,GAAiB,CACf,QAAA,MAAM,yBAAyBwE,MAAYxE,CAAK,EACxD6E,EAAa,CAAE,QAAS,GAAO,MAAO7E,EAAM,QAAS,CAAA,CACtD,EAEI,EAEX,CAEO,MAAA,EACT,CACF,EAGA,eAAe+E,GAAsB,CACnC,QAAQ,IAAI,2BAA2B,EAGjC,MAAA9E,EAAY,MAAMR,IACpB,GAAAQ,EAAU,OAAS,EAAG,CAChB,QAAA,IAAI,SAASA,EAAU,kBAAkB,EAG3C,MAAA+E,EAAM,KAAK,MAoBXC,EAAkBhF,EAAU,OAAQuC,GAAMA,EAAE,UAAYwC,CAAG,EAC7D,GAAAC,EAAgB,OAAS,EAAG,CACtB,QAAA,IACN,yBAAyBA,EAAgB,yBAAA,EAG3C,UAAWvF,KAAYuF,EACjB,GAAA,CACK,OAAA,OAAO,OAAOvF,EAAS,WAAY,CACxC,KAAMA,EAAS,SAAA,CAChB,EACO,QAAA,IACN,8BAA8BA,EAAS,iBAAiB,IAAI,KAC1DA,EAAS,SAAA,EACT,YAAY,GAAA,QAETM,GACC,QAAA,MACN,qCAAqCN,EAAS,cAC9CM,CAAA,CAEJ,CAEJ,CACF,CACF,CAGA+E,IAAsB,MAAO/E,GAAU,CAC7B,QAAA,MAAM,gCAAiCA,CAAK,CACtD,CAAC"}