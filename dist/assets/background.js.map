{"version":3,"file":"background.js","sources":["../../src/content/background.ts"],"sourcesContent":["// background.ts\nimport {\n  Alarm,\n  createSchedule,\n  deleteSchedule,\n  getSchedules,\n  Schedule,\n  updateScheduleStatus,\n} from \"../utils/scheduleUtils\";\nimport { handleScheduleTrigger } from \"../utils/scheduleTriggerService\";\nimport { NoteDraftImage, prepareAttachmentsForNote } from \"../utils/imageUtils\";\nimport { log, logError } from \"../utils/logger\";\nimport { API_BASE_URL } from \"@/utils/api\";\n\ninterface Response<T> {\n  message: string;\n  action: string;\n  result: T;\n}\n\n// Image upload result interface\ninterface ImageUploadResult {\n  url: string;\n  success: boolean;\n  attachmentId?: string;\n}\n\n// Enhanced logging function\nfunction logScheduledPost(message: string, data?: any) {\n  const timestamp = new Date().toISOString();\n  console.log(`[SCHEDULED POST ${timestamp}] ${message}`, data ? data : \"\");\n}\n\n// Define API handler types\ntype ApiHandlers = {\n  createSubstackPost: (note?: {\n    bodyJson: any;\n    attachmentUrls?: string[];\n  }) => Promise<Response<any>>;\n  getSubstackCookies: () => Promise<Response<string>>;\n  setSubstackCookies: () => Promise<Response<any>>;\n  createSchedule: (schedule: {\n    scheduleId: string;\n    userId: string;\n    timestamp: number;\n    noteId?: string;\n  }) => Promise<Response<Schedule>>;\n  deleteSchedule: (scheduleId: string) => Promise<Response<boolean>>;\n  getSchedules: () => Promise<\n    Response<{ schedules: Schedule[]; alarms: Alarm[] }>\n  >;\n  uploadImagesToSubstack: (\n    imageUrls: string[]\n  ) => Promise<Response<ImageUploadResult[]>>;\n};\n\n// API request handlers\nconst apiHandlers: ApiHandlers = {\n  getSubstackCookies: async (): Promise<Response<string>> => {\n    return new Promise((resolve, reject) => {\n      chrome.cookies.getAll({ domain: \"substack.com\" }, (cookies) => {\n        if (chrome.runtime.lastError) {\n          logError(\"Error fetching cookies:\", chrome.runtime.lastError);\n          reject(chrome.runtime.lastError.message);\n          return;\n        }\n\n        if (!cookies || cookies.length === 0) {\n          console.warn(\"No Substack cookies found.\");\n          resolve({\n            message: \"No Substack cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        // Only keep relevant cookies\n        const relevantCookieNames = [\"substack.sid\", \"__cf_bm\", \"substack.lli\"];\n        log(\"Cookies:\", cookies);\n        const relevantCookies = cookies.filter((c) =>\n          relevantCookieNames.includes(c.name)\n        );\n\n        if (relevantCookies.length === 0) {\n          console.warn(\"No relevant Substack auth cookies found.\");\n          resolve({\n            message: \"No relevant Substack auth cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        const cookieDetails = relevantCookies.map((cookie) => ({\n          name: cookie.name,\n          value: cookie.value,\n          expiresAt: cookie.expirationDate || null,\n          domain: cookie.domain,\n          path: cookie.path,\n          secure: cookie.secure,\n          httpOnly: cookie.httpOnly,\n          sameSite: cookie.sameSite || \"unspecified\",\n        }));\n\n        const result = JSON.stringify(cookieDetails);\n\n        resolve({\n          message: \"Cookies fetched successfully\",\n          action: \"SUBSTACK_COOKIES_FETCHED\",\n          result: result,\n        });\n      });\n    });\n  },\n\n  // Create a post on Substack\n  createSubstackPost: async (note?: {\n    bodyJson: any;\n    attachmentUrls?: string[];\n  }) => {\n    try {\n      let attachments: NoteDraftImage[] = [];\n      if (!note) {\n        return {\n          success: false,\n          message: \"No note provided\",\n          action: \"SUBSTACK_POST_CREATE\",\n          result: JSON.stringify({ error: \"No note provided\" }),\n        };\n      }\n\n      if (note?.attachmentUrls && note.attachmentUrls.length > 0) {\n        attachments = await prepareAttachmentsForNote(note.attachmentUrls);\n      }\n\n      const body =\n        attachments.length > 0\n          ? JSON.stringify({\n              bodyJson: note?.bodyJson,\n              attachmentIds: attachments.map((a) => a.id),\n            })\n          : JSON.stringify({\n              bodyJson: note?.bodyJson,\n            });\n\n      console.log(\"Body:\", body);\n\n      const response = await fetch(\"https://substack.com/api/v1/comment/feed\", {\n        headers: {\n          \"content-type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n          Origin: \"https://substack.com\",\n        },\n        credentials: \"include\", // Required to send cookies\n        body,\n        method: \"POST\",\n      });\n      const text = await response.text();\n      const data = JSON.parse(text);\n      if (!response.ok) {\n        log(\"Response of Send note:\", response);\n        log(\"Data of Send note:\", data);\n        log(\"Text of Send note:\", text);\n        return {\n          success: false,\n          message: \"Failed to create post\",\n          action: \"SUBSTACK_POST_CREATES\",\n          result: JSON.stringify({ error: \"Failed to create post\" }),\n        };\n      }\n      log(\"Response:\", response);\n      log(\"Data after post sent:\", data);\n      return {\n        message: \"Post created successfully\",\n        action: \"SUBSTACK_POST_CREATED\",\n        result: JSON.stringify(data),\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      log(\"Error creating Substack post\", { error: errorMessage });\n      logError(\"Error creating Substack post:\", error);\n      throw error;\n    }\n  },\n\n  setSubstackCookies: async () => {\n    const response = await apiHandlers.getSubstackCookies();\n    const parsedCookies = JSON.parse(response.result);\n    log(\"Sending to server:\", JSON.stringify(parsedCookies));\n\n    try {\n      const cookiesResponse = await fetch(`${API_BASE_URL}/api/user/cookies`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(parsedCookies),\n      });\n      if (!cookiesResponse.ok) {\n        logError(\"Failed to send cookies to server\");\n        return response;\n      }\n      const data = await cookiesResponse.json();\n      log(\"Cookies sent to server successfully\", data);\n      return response;\n    } catch (error) {\n      logError(\"Error sending cookies to server:\", error);\n      return response;\n    }\n  },\n\n  // Create a new schedule\n  createSchedule: async (\n    schedule: {\n      scheduleId: string;\n      userId: string;\n      timestamp: number;\n      noteId?: string;\n    }\n  ): Promise<Response<Schedule>> => {\n    try {\n      const { scheduleId, userId, timestamp, noteId } = schedule;\n      // Create schedule in extension storage\n      log(\"Creating schedule\", { scheduleId, userId, timestamp });\n      const scheduleCreated = await createSchedule({\n        scheduleId,\n        userId,\n        timestamp,\n        noteId,\n      });\n      log(\"Schedule created successfully\", scheduleCreated);\n      return {\n        message: \"Schedule created successfully\",\n        action: \"SCHEDULE_CREATED\",\n        result: schedule,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error creating schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  deleteSchedule: async (scheduleId: string): Promise<Response<boolean>> => {\n    try {\n      // Delete schedule from extension storage\n      const result = await deleteSchedule(scheduleId);\n      return {\n        message: result\n          ? \"Schedule deleted successfully\"\n          : \"Schedule not found\",\n        action: \"SCHEDULE_DELETED\",\n        result,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error deleting schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Get all schedules\n  getSchedules: async (): Promise<\n    Response<{ schedules: Schedule[]; alarms: Alarm[] }>\n  > => {\n    try {\n      // Get schedules from extension storage\n      const { schedules, alarms } = await getSchedules();\n      return {\n        message: `Found ${schedules.length} schedules`,\n        action: \"SCHEDULES_FETCHED\",\n        result: { schedules, alarms },\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error getting schedules:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Upload multiple images to Substack\n  uploadImagesToSubstack: async (\n    imageUrls: string[]\n  ): Promise<Response<ImageUploadResult[]>> => {\n    log(\"Uploading images to Substack:\", imageUrls);\n\n    if (!imageUrls || !imageUrls.length) {\n      return {\n        message: \"No images to upload\",\n        action: \"IMAGES_UPLOADED\",\n        result: [],\n      };\n    }\n\n    // Process each image URL, tracking results\n    const results: ImageUploadResult[] = [];\n\n    try {\n      log(\"Preparing attachments for note\", imageUrls);\n      // Use prepareAttachmentsForNote to process all images\n      const attachments = await prepareAttachmentsForNote(imageUrls);\n\n      // Create result entries for successful uploads\n      const successfulUploads = new Map<string, NoteDraftImage>();\n      attachments.forEach((attachment) => {\n        successfulUploads.set(attachment.url, attachment);\n      });\n\n      // Create result for each original URL\n      for (const imageUrl of imageUrls) {\n        const attachment = successfulUploads.get(imageUrl);\n\n        if (attachment) {\n          results.push({\n            url: imageUrl,\n            success: true,\n            attachmentId: attachment.id,\n          });\n        } else {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Successfully uploaded ${attachments.length} of ${imageUrls.length} images`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error uploading images to Substack:\", errorMessage);\n\n      // For any remaining URLs not in results, add failed entries\n      const processedUrls = new Set(results.map((r) => r.url));\n\n      for (const imageUrl of imageUrls) {\n        if (!processedUrls.has(imageUrl)) {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Error uploading images: ${errorMessage}`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    }\n  },\n};\n\n// Define message types\ninterface ApiRequestMessage {\n  type: \"API_REQUEST\" | \"PING\";\n  action: keyof ApiHandlers;\n  params?: unknown[];\n}\n\ninterface GenerateIdeasMessage {\n  type: \"GENERATE_IDEAS\";\n}\n\ntype ChromeMessage = ApiRequestMessage | GenerateIdeasMessage;\n\n// Helper function to safely call API handlers with dynamic parameters\nfunction callApiHandler(\n  action: keyof ApiHandlers,\n  params: unknown[] = []\n): Promise<any> {\n  switch (action) {\n    case \"getSubstackCookies\":\n      return apiHandlers.getSubstackCookies();\n    case \"setSubstackCookies\":\n      return apiHandlers.setSubstackCookies();\n    case \"createSubstackPost\":\n      return apiHandlers.createSubstackPost(\n        params[0] as\n          | {\n              bodyJson: any;\n              attachmentIds?: string[];\n            }\n          | undefined\n      );\n    case \"createSchedule\":\n      return apiHandlers.createSchedule(\n        {\n          scheduleId: params[0] as string,\n          userId: params[1] as string,\n          timestamp: params[2] as number,\n          noteId: params[3] as string | undefined,\n        }\n      );\n    case \"deleteSchedule\":\n      return apiHandlers.deleteSchedule(params[0] as string);\n    case \"getSchedules\":\n      return apiHandlers.getSchedules();\n    case \"uploadImagesToSubstack\":\n      return apiHandlers.uploadImagesToSubstack(params[0] as string[]);\n    default:\n      return Promise.reject(new Error(`Unknown action: ${action}`));\n  }\n}\n\nlet isSending = false;\n\n// Set up alarm listener for schedule triggers\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n  log(`Alarm triggered: ${alarm.name}`);\n\n  // Check if this is a schedule alarm\n  const { schedules } = await getSchedules();\n  const schedule = schedules.find((s) => s.scheduleId === alarm.name);\n\n  if (schedule) {\n    log(`Processing schedule: ${schedule.scheduleId}`);\n    try {\n      const result = await handleScheduleTrigger(schedule);\n      log(`Schedule ${schedule.scheduleId} processed:`, result);\n      if (result.status === \"sent\") {\n        // Delete the schedule after processing\n        await deleteSchedule(schedule.scheduleId);\n      } else {\n        if (result.status === \"processing\") {\n          return;\n        }\n        // update the status and error\n        await updateScheduleStatus(\n          schedule.scheduleId,\n          result.status,\n          result.error\n        );\n      }\n    } catch (error) {\n      logError(`Error handling schedule ${schedule.scheduleId}:`, error);\n    }\n  }\n});\n\nchrome.runtime.onMessageExternal.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    log(\"Background script received external message:\", {\n      request,\n      sender: sender?.url,\n      type: request?.type,\n    });\n\n    // Handle PING message - respond immediately without async\n    if (request?.type === \"PING\") {\n      log(\"Received external PING, responding immediately\");\n      const version = chrome.runtime.getManifest().version;\n      log(\"Version:\", version);\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        version,\n        message: \"Extension is active\",\n        source: \"external\",\n      });\n      return false; // No async response needed\n    }\n\n    // Handle API requests\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      log(\"Received API request:\", { action, params });\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            if (data.success !== false) {\n              sendResponse({ success: true, data });\n            } else {\n              logError(`Error in API request (${action}):`, data);\n              sendResponse({ success: false, error: data.error });\n            }\n          })\n          .catch((error: Error) => {\n            logError(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n        return true; // Will respond asynchronously\n      }\n    }\n\n    return false;\n  }\n);\n\nchrome.runtime.onMessage.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    log(\n      `Background got internal from ${sender.url} message: ${JSON.stringify(\n        request\n      )}`\n    );\n\n    if (request?.type === \"PING\") {\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        message: \"Extension is active\",\n        source: \"internal\",\n      });\n      return false;\n    }\n\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      log(\"API request:\", { action, params });\n\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            logError(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n);\n"],"names":["apiHandlers","resolve","reject","cookies","logError","relevantCookieNames","log","relevantCookies","c","cookieDetails","cookie","result","note","attachments","prepareAttachmentsForNote","body","a","response","text","data","error","errorMessage","parsedCookies","cookiesResponse","API_BASE_URL","schedule","scheduleId","userId","timestamp","noteId","scheduleCreated","createSchedule","deleteSchedule","schedules","alarms","getSchedules","imageUrls","results","successfulUploads","attachment","imageUrl","processedUrls","r","callApiHandler","action","params","alarm","s","handleScheduleTrigger","updateScheduleStatus","request","sender","sendResponse","version"],"mappings":"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"}