{"version":3,"file":"background.js","sources":["../../src/utils/logger.ts","../../src/utils/scheduleUtils.ts","../../src/utils/request.ts","../../src/utils/imageUtils.ts","../../src/utils/scheduleTriggerService.ts","../../src/content/background.ts"],"sourcesContent":["const API_BASE_URL = \"https://www.writestack.io\";\n// const API_BASE_URL = \"http://localhost:3000\";\nconst LOG_ENDPOINT = \"api/v1/extension/log\";\n\n/**\n * Enhanced logging function that logs to console and sends to server\n * @param message Message to log\n * @param data Optional data to include with the log\n */\nexport async function log(message: string, data?: any): Promise<void> {\n  // Always log to console first\n  if (data !== undefined) {\n    console.log(message, data);\n  } else {\n    console.log(message);\n  }\n\n  try {\n    // Prepare the log payload\n    const payload = {\n      message,\n      data: data !== undefined ? JSON.stringify(data) : undefined,\n      timestamp: new Date().toISOString(),\n      source: \"extension\",\n      level: \"info\",\n    };\n\n    // Send to server endpoint\n    await fetch(`${API_BASE_URL}/${LOG_ENDPOINT}`, {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      credentials: \"include\", // Include cookies automatically\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n  } catch (error) {\n    // If logging to server fails, just log to console but don't throw\n    console.error(\"Failed to send log to server:\", error);\n  }\n}\n\n/**\n * Enhanced error logging function that logs to console and sends to server\n * @param message Error message to log\n * @param data Optional error data to include with the log\n */\nexport async function logError(message: string, data?: any): Promise<void> {\n  // Always log to console first\n  if (data !== undefined) {\n    console.error(message, data);\n  } else {\n    console.error(message);\n  }\n\n  try {\n    // Prepare the log payload\n    const payload = {\n      message,\n      data: data !== undefined ? JSON.stringify(data) : undefined,\n      timestamp: new Date().toISOString(),\n      source: \"extension\",\n      level: \"error\",\n    };\n\n    // Send to server endpoint\n    await fetch(`${API_BASE_URL}/${LOG_ENDPOINT}`, {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      credentials: \"include\", // Include cookies automatically\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    });\n  } catch (error) {\n    // If logging to server fails, just log to console but don't throw\n    console.error(\"Failed to send error log to server:\", error);\n  }\n}\n","// src/utils/scheduleUtils.ts\nimport { log, logError } from \"./logger\";\n\n// Schedule data interface\nexport interface Schedule {\n  scheduleId: string;\n  userId: string;\n  timestamp: number;\n  substackNoteId?: string;\n  isProcessing?: boolean;\n}\n\nexport interface Alarm {\n  name: string;\n  scheduledTime: number;\n  periodInMinutes?: number | undefined;\n}\n// Storage key for schedules\nconst SCHEDULES_STORAGE_KEY = \"writestack_schedules\";\n\n/**\n * Create a new schedule\n * @param scheduleId Unique identifier for the schedule\n * @param userId User identifier\n * @param timestamp Unix timestamp when the schedule should trigger\n * @returns Promise resolving to the created schedule\n */\nexport async function createSchedule(\n  scheduleId: string,\n  userId: string,\n  timestamp: number\n): Promise<Schedule> {\n  // Validate parameters\n  if (!scheduleId || !userId || !timestamp) {\n    throw new Error(\"Invalid schedule parameters\");\n  }\n\n  // Get existing schedules\n  const { schedules, alarms } = await getSchedules();\n\n  // Check if schedule with same ID already exists\n  const scheduleExists = schedules.some(\n    (schedule) => schedule.scheduleId === scheduleId\n  );\n  if (scheduleExists) {\n    throw new Error(`Schedule with ID ${scheduleId} already exists`);\n  }\n\n  // Create new schedule\n  const newSchedule: Schedule = {\n    scheduleId,\n    userId,\n    timestamp,\n  };\n\n  // Add schedule to storage\n  const updatedSchedules = [...schedules, newSchedule];\n  await saveSchedules(updatedSchedules);\n\n  // Create an alarm for this schedule\n  await createAlarmForSchedule(newSchedule);\n\n  log(\n    `Schedule created: ${scheduleId} at ${new Date(timestamp).toISOString()}`\n  );\n\n  const allAlarms = await chrome.alarms.getAll();\n  log(\"All alarms\", allAlarms);\n\n  return newSchedule;\n}\n\n/**\n * Delete a schedule by ID\n * @param scheduleId ID of the schedule to delete\n * @returns Promise resolving to boolean indicating success\n */\nexport async function deleteSchedule(scheduleId: string): Promise<boolean> {\n  // Get existing schedules\n  const { schedules, alarms } = await getSchedules();\n\n  // Filter out the schedule to delete\n  const updatedSchedules = schedules.filter(\n    (schedule) => schedule.scheduleId !== scheduleId\n  );\n\n  // If no schedule was removed, return true\n  if (updatedSchedules.length === schedules.length) {\n    return true;\n  }\n\n  // Delete the alarm for this schedule\n  try {\n    await chrome.alarms.clear(scheduleId);\n    // delete from storage\n  } catch (error) {\n    logError(`Failed to clear alarm for schedule ${scheduleId}:`, error);\n  }\n\n  // Save updated schedules\n  await saveSchedules(updatedSchedules);\n  log(`Schedule deleted: ${scheduleId}`);\n  return true;\n}\n\n/**\n * Get all schedules\n * @returns Promise resolving to array of schedules\n */\nexport async function getSchedules(): Promise<{\n  schedules: Schedule[];\n  alarms: Alarm[];\n}> {\n  try {\n    const result = await chrome.storage.local.get(SCHEDULES_STORAGE_KEY);\n    const schedules = result[SCHEDULES_STORAGE_KEY] || [];\n    const alarms = await chrome.alarms.getAll();\n    return {\n      schedules,\n      alarms,\n    };\n  } catch (error) {\n    logError(\"Failed to get schedules:\", error);\n    return {\n      schedules: [],\n      alarms: [],\n    };\n  }\n}\n\n/**\n * Save schedules to storage\n * @param schedules Array of schedules to save\n * @returns Promise that resolves when schedules are saved\n */\nexport async function saveSchedules(schedules: Schedule[]): Promise<void> {\n  try {\n    log(\"Saving schedules\", schedules);\n    await chrome.storage.local.set({ [SCHEDULES_STORAGE_KEY]: schedules });\n  } catch (error) {\n    logError(\"Failed to save schedules:\", error);\n    throw new Error(\"Failed to save schedules\");\n  }\n}\n\n// /**\n//  * Finds all duplicate alarms and removes them\n//  * @param schedule\n//  */\n// async function clearDuplicateAlarms(): Promise<void> {\n//   try {\n//     console.log(\"Clearing duplicate alarms\");\n//     const allAlarms = await chrome.alarms.getAll();\n//     // go over all alarms and remove duplicates\n//     for (const alarm of allAlarms) {\n//       const duplicateAlarm = allAlarms.find(\n//         (a) => a.name === alarm.name && a.scheduledTime === alarm.scheduledTime\n//       );\n//       if (duplicateAlarm) {\n//         console.log(\"Clearing duplicate alarm\", duplicateAlarm.name);\n//         await chrome.alarms.clear(duplicateAlarm.name);\n//       }\n//     }\n//   } catch (error) {\n//     console.error(\"Failed to clear duplicate alarms:\", error);\n//   }\n// }\n\n/**\n * Create a Chrome alarm for a schedule\n * @param schedule Schedule to create alarm for\n */\nasync function createAlarmForSchedule(schedule: Schedule): Promise<void> {\n  try {\n    // Create alarm with schedule ID as name\n    log(\"Creating alarm for schedule\", schedule.scheduleId);\n    const allAlarms = await chrome.alarms.getAll();\n    if (allAlarms.find((a) => a.name === schedule.scheduleId)) {\n      log(\"Alarm already exists for schedule\", schedule.scheduleId);\n      return;\n    }\n    chrome.alarms.create(schedule.scheduleId, {\n      when: schedule.timestamp,\n    });\n    // await clearDuplicateAlarms();\n    log(\n      `Alarm created for schedule ${schedule.scheduleId} at ${new Date(\n        schedule.timestamp\n      ).toISOString()}`\n    );\n  } catch (error) {\n    logError(\n      `Failed to create alarm for schedule ${schedule.scheduleId}:`,\n      error\n    );\n    throw new Error(\"Failed to create alarm for schedule\");\n  }\n}\n","import { log, logError } from \"./logger\";\n\n// const API_BASE_URL = \"https://9107-109-186-108-120.ngrok-free.app\";\nconst API_BASE_URL = \"https://www.writestack.io\";\n// const API_BASE_URL = \"http://localhost:3000\";\n\nexport async function makeAuthenticatedRequest(\n  endpoint: string,\n  options: RequestInit = {},\n  baseUrl?: string\n) {\n  try {\n    let url = `${baseUrl || API_BASE_URL}/${endpoint}`;\n    // replace accidental double \\\\ with single \\\n    url = url.replace(\"\\\\\\\\\", \"\\\\\");\n    log(\"Making request\", { url, options });\n    const response = await fetch(url, {\n      ...options,\n      credentials: \"include\", // Include cookies automatically\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options.headers,\n      },\n    });\n\n    if (!response.ok) {\n      const text = await response.text();\n      log(\"Request failed\", { status: response.status, response: text });\n      return {\n        success: false,\n        error: text,\n        status: response.status,\n      };\n    }\n\n    const json = await response.json();\n    log(\"Response json\", json);\n\n    return {\n      success: true,\n      data: json,\n      status: response.status,\n    };\n  } catch (error: any) {\n    logError(\"Request failed\", error);\n    return {\n      success: false,\n      error: error.message,\n      status: 500,\n    };\n  }\n}\n","// src/utils/imageUtils.ts\nimport { log, logError } from \"./logger\";\n\n// Interface for Substack image returned from API\nexport interface NoteDraftImage {\n  id: string;\n  url: string;\n}\n\n// Interface for Substack image response\ninterface SubstackImageResponse {\n  id: string;\n  imageUrl: string;\n  imageWidth: number;\n  imageHeight: number;\n  explicit: boolean;\n}\n\n/**\n * Download an image from a URL and return it as Uint8Array\n * @param url URL of the image to download\n * @returns Promise resolving to Uint8Array of image data or null if failed\n */\nexport async function downloadImage(url: string): Promise<Uint8Array | null> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      const responseText = await response.text();\n      logError(\n        `Failed to fetch image from ${url}, got status: ${response.status}, response: ${responseText}`\n      );\n      return null;\n    }\n\n    const arrayBuffer = await response.arrayBuffer();\n    return new Uint8Array(arrayBuffer);\n  } catch (error) {\n    logError(`Error downloading image from ${url}:`, error);\n    return null;\n  }\n}\n\n/**\n * Upload an image to Substack\n * @param image Image data as Uint8Array\n * @param userId User ID\n * @param noteId Note ID\n * @returns Promise resolving to the uploaded image data\n */\nexport async function uploadImageSubstack(\n  image: Uint8Array\n): Promise<NoteDraftImage> {\n  if (!image) {\n    throw new Error(\"Invalid image data\");\n  }\n\n  try {\n    // Convert image to base64\n    const base64 = arrayBufferToBase64(image);\n    const dataUri = `data:image/png;base64,${base64}`;\n\n    log(\"Uploading image to Substack\", dataUri);\n\n    // Upload image to Substack\n    const uploadImageResponse = await fetch(\n      \"https://substack.com/api/v1/image\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n          \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        },\n        body: JSON.stringify({ image: dataUri }),\n        method: \"POST\",\n      }\n    );\n\n    if (!uploadImageResponse.ok) {\n      const responseText = await uploadImageResponse.text();\n      logError(`Failed to upload image to Substack: ${responseText}`);\n      throw new Error(\"Failed to upload image to Substack\");\n    }\n\n    const data = await uploadImageResponse.json();\n\n    // Get image attachment from Substack\n    const getImageResponse = await fetch(\n      \"https://substack.com/api/v1/comment/attachment\",\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n          \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        },\n        method: \"POST\",\n        body: JSON.stringify({ type: \"image\", url: data.url }),\n      }\n    );\n\n    if (!getImageResponse.ok) {\n      const responseText = await getImageResponse.text();\n      logError(`Failed to get image from Substack: ${responseText}`);\n      throw new Error(\"Failed to get image from Substack\");\n    }\n\n    const imageData: SubstackImageResponse = await getImageResponse.json();\n\n    // Store the image info\n    const noteDraftImage: NoteDraftImage = {\n      id: imageData.id,\n      url: imageData.imageUrl,\n    };\n\n    log(`Image uploaded to Substack: ${noteDraftImage.id}`);\n    return noteDraftImage;\n  } catch (error) {\n    logError(\"Error uploading image to Substack:\", error);\n    throw new Error(\"Failed to upload image to Substack\");\n  }\n}\n\n/**\n * Convert Uint8Array to base64 string\n * @param buffer Uint8Array to convert\n * @returns Base64 string\n */\nfunction arrayBufferToBase64(buffer: Uint8Array): string {\n  let binary = \"\";\n  const bytes = new Uint8Array(buffer);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\n/**\n * Prepare multiple attachments for a note\n * @param urls Array of image URLs to upload\n * @param userId User ID\n * @param noteId Note ID\n * @returns Promise resolving to array of uploaded images\n */\nexport async function prepareAttachmentsForNote(\n  urls: string[],\n): Promise<NoteDraftImage[]> {\n  if (!urls || urls.length === 0) {\n    return [];\n  }\n\n  const maxAttachments = 4;\n  const attachmentsToUpload = urls.slice(0, maxAttachments);\n  const attachments: NoteDraftImage[] = [];\n\n  log(\"Uploading attachments\", attachmentsToUpload);\n\n  for (const url of attachmentsToUpload) {\n    try {\n      // Download the image\n      const buffer = await downloadImage(url);\n      if (!buffer) {\n        logError(`Failed to download image from ${url}`);\n        continue;\n      }\n\n      log(\"Got buffer! with length\", buffer.length);\n\n      // Upload to Substack\n      const substackImage = await uploadImageSubstack(buffer);\n      attachments.push(substackImage);\n    } catch (error) {\n      logError(`Error processing attachment from ${url}:`, error);\n    }\n  }\n\n  return attachments;\n}\n","import { makeAuthenticatedRequest } from \"@/utils/request\";\nimport { NoteDraftImage, prepareAttachmentsForNote } from \"./imageUtils\";\nimport { getSchedules, saveSchedules, Schedule } from \"./scheduleUtils\";\nimport { log, logError } from \"./logger\";\n\n// API endpoint for schedule triggers\nconst getScheduleTriggerAPI = (scheduleId: string) =>\n  `api/v1/extension/schedule/${scheduleId}/triggered`;\nconst getScheduleAPI = (scheduleId: string) =>\n  `api/v1/extension/schedule/${scheduleId}`;\n// TODO: Make sure that if writestack.io is open, open a new Substack tab to send the post.\n\n// Response from the API when a schedule is triggered\ninterface ScheduleTriggerResponse {\n  jsonBody: any;\n  attachmentUrls: string[];\n}\n\n// Result of posting to Substack\ninterface PostToSubstackResult {\n  success: boolean;\n  error?: string;\n  data?: any;\n}\n\n/**\n * Handle a triggered schedule\n * @param schedule The schedule that was triggered\n * @returns Promise that resolves when the schedule has been handled\n */\nexport async function handleScheduleTrigger(schedule: Schedule): Promise<void> {\n  log(`Handling triggered schedule: ${schedule.scheduleId}`);\n\n  const { schedules } = await getSchedules();\n  const freshSchedule = schedules.find(\n    (s) => s.scheduleId === schedule.scheduleId\n  );\n  if (!freshSchedule || freshSchedule.isProcessing) {\n    log(`Skipping already processing schedule ${schedule.scheduleId}`);\n    return;\n  }\n  try {\n    // update the schedule as processing\n    freshSchedule.isProcessing = true;\n    await saveSchedules([\n      ...schedules.filter((s) => s.scheduleId !== schedule.scheduleId),\n      freshSchedule,\n    ]);\n\n    // Notify the API that a schedule has been triggered\n    const response = await getSchedule(schedule.scheduleId);\n    log(\"getSchedule response\", response);\n    // If the jsonBody is empty, notify the API of the error\n    if (!response || !response.jsonBody) {\n      logError(`Empty body received for schedule: ${schedule.scheduleId}`);\n      await notifyScheduleTrigger(schedule, false, \"EMPTY_BODY\");\n      return;\n    }\n\n    // Process attachments if any\n    let attachments: NoteDraftImage[] = [];\n    if (response.attachmentUrls && response.attachmentUrls.length > 0) {\n      try {\n        log(\"Preparing attachments\", response.attachmentUrls);\n        attachments = await prepareAttachmentsForNote(response.attachmentUrls);\n      } catch (error) {\n        logError(\n          `Failed to prepare attachments for schedule ${schedule.scheduleId}:`,\n          error\n        );\n        await notifyScheduleTrigger(\n          schedule,\n          false,\n          \"FAILED_TO_PREPARE_ATTACHMENTS\",\n          String(error)\n        );\n        return;\n      }\n    }\n\n    // Post to Substack\n    try {\n      log(\"Posting to Substack\", response.jsonBody);\n      const postResult = await postToSubstack({\n        jsonBody: response.jsonBody,\n        attachmentIds: attachments.map((a) => a.id),\n      });\n      log(\"Post result\", postResult);\n      if (postResult.success) {\n        await notifyScheduleTrigger(\n          { ...schedule, substackNoteId: postResult.data?.id },\n          true\n        );\n        log(\n          `Successfully posted to Substack for schedule: ${schedule.scheduleId}`\n        );\n      } else {\n        await notifyScheduleTrigger(\n          schedule,\n          false,\n          \"FAILED_TO_POST_TO_SUBSTACK\",\n          postResult.error\n        );\n        logError(\n          `Failed to post to Substack for schedule ${schedule.scheduleId}:`,\n          postResult.error\n        );\n      }\n    } catch (error) {\n      logError(\n        `Error posting to Substack for schedule ${schedule.scheduleId}:`,\n        error\n      );\n      await notifyScheduleTrigger(\n        schedule,\n        false,\n        \"FAILED_TO_CREATE_NOTE\",\n        String(error)\n      );\n    }\n  } catch (error) {\n    logError(\n      `Error handling schedule trigger for ${schedule.scheduleId}:`,\n      error\n    );\n    await notifyScheduleTrigger(\n      schedule,\n      false,\n      \"GENERAL_ERROR\",\n      String(error)\n    );\n  } finally {\n    // update the schedule as not processing\n    freshSchedule.isProcessing = false;\n    await saveSchedules([\n      ...schedules.filter((s) => s.scheduleId !== schedule.scheduleId),\n      freshSchedule,\n    ]);\n  }\n}\n\n/**\n * Notify the API that a schedule has been triggered\n * @param schedule The schedule that was triggered\n * @returns Promise resolving to the API response\n */\nasync function getSchedule(\n  scheduleId: string\n): Promise<ScheduleTriggerResponse | null> {\n  try {\n    log(\"Getting schedule\", scheduleId);\n    const schedule = await makeAuthenticatedRequest(\n      getScheduleAPI(scheduleId),\n      {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n\n    if (!schedule || !schedule.success) {\n      logError(`Error getting schedule ${scheduleId}: ${schedule?.error}`);\n      return null;\n    }\n\n    return schedule.data;\n  } catch (error) {\n    logError(`Error getting schedule ${scheduleId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Notify the API about the result of a schedule trigger\n * @param schedule The schedule that was triggered\n * @param ok Whether the schedule was successfully handled\n * @param error Error message if not successful\n * @param text Additional error details\n * @returns Promise that resolves when the API has been notified\n */\nasync function notifyScheduleTrigger(\n  schedule: Schedule,\n  ok: boolean,\n  error?: string,\n  text?: string\n): Promise<void> {\n  try {\n    const body: any = {\n      ok,\n      substackNoteId: schedule.substackNoteId,\n    };\n\n    if (!ok && error) {\n      body.error = error;\n      if (text) {\n        body.text = text;\n      }\n    }\n\n    const response = await makeAuthenticatedRequest(\n      getScheduleTriggerAPI(schedule.scheduleId),\n      {\n        method: \"POST\",\n        body: JSON.stringify(body),\n      }\n    );\n\n    if (!response || !response.success) {\n      logError(\n        `Error notifying API about schedule result: ${response.status} ${response.error}`\n      );\n    }\n  } catch (error) {\n    logError(`Error notifying API about schedule result:`, error);\n  }\n}\n\n/**\n * Post content to Substack\n * @param body JSON body to post\n * @returns Promise resolving to the result of the post\n */\nasync function postToSubstack(body: {\n  jsonBody: any;\n  attachmentIds: string[];\n}): Promise<PostToSubstackResult> {\n  try {\n    // Convert body to string if it's an object\n    const requestBody: any = {\n      bodyJson: body.jsonBody,\n    };\n    if (body.attachmentIds.length > 0) {\n      requestBody.attachmentIds = body.attachmentIds;\n    }\n    const bodyContent = JSON.stringify(requestBody);\n\n    const response = await fetch(\"https://substack.com/api/v1/comment/feed\", {\n      headers: {\n        \"content-type\": \"application/json\",\n        Referer: \"https://substack.com/home\",\n      },\n      body: bodyContent,\n      method: \"POST\",\n    });\n\n    if (!response.ok) {\n      const responseText = await response.text();\n      log(\"Error posting to Substack, response:\", responseText);\n      return {\n        success: false,\n        error: `API returned error: ${response.status} ${responseText}`,\n      };\n    }\n\n    log(\"Posting to Substack, response:\", response);\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return {\n      success: false,\n      error: String(error),\n    };\n  }\n}\n","// background.ts\nimport {\n  Alarm,\n  createSchedule,\n  deleteSchedule,\n  getSchedules,\n  Schedule,\n} from \"../utils/scheduleUtils\";\nimport { handleScheduleTrigger } from \"../utils/scheduleTriggerService\";\nimport { NoteDraftImage, prepareAttachmentsForNote } from \"../utils/imageUtils\";\nimport { log, logError } from \"../utils/logger\";\n\n// Base URL for API requests\nconst API_BASE_URL = \"https://www.writestack.io\";\n\ninterface Response<T> {\n  message: string;\n  action: string;\n  result: T;\n}\n\n// Image upload result interface\ninterface ImageUploadResult {\n  url: string;\n  success: boolean;\n  attachmentId?: string;\n}\n\n// Enhanced logging function\nfunction logScheduledPost(message: string, data?: any) {\n  const timestamp = new Date().toISOString();\n  console.log(`[SCHEDULED POST ${timestamp}] ${message}`, data ? data : \"\");\n}\n\n// Define API handler types\ntype ApiHandlers = {\n  createSubstackPost: (\n    message?: string,\n    scheduleSeconds?: number,\n    autoCloseTab?: boolean\n  ) => Promise<Response<any>>;\n  getSubstackCookies: () => Promise<Response<string>>;\n  setSubstackCookies: () => Promise<Response<any>>;\n  createSchedule: (\n    scheduleId: string,\n    userId: string,\n    timestamp: number\n  ) => Promise<Response<Schedule>>;\n  deleteSchedule: (scheduleId: string) => Promise<Response<boolean>>;\n  getSchedules: () => Promise<\n    Response<{ schedules: Schedule[]; alarms: Alarm[] }>\n  >;\n  uploadImagesToSubstack: (\n    imageUrls: string[]\n  ) => Promise<Response<ImageUploadResult[]>>;\n};\n\n// API request handlers\nconst apiHandlers: ApiHandlers = {\n  getSubstackCookies: async (): Promise<Response<string>> => {\n    return new Promise((resolve, reject) => {\n      chrome.cookies.getAll({ domain: \"substack.com\" }, (cookies) => {\n        if (chrome.runtime.lastError) {\n          logError(\"Error fetching cookies:\", chrome.runtime.lastError);\n          reject(chrome.runtime.lastError.message);\n          return;\n        }\n\n        if (!cookies || cookies.length === 0) {\n          console.warn(\"No Substack cookies found.\");\n          resolve({\n            message: \"No Substack cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        // Only keep relevant cookies\n        const relevantCookieNames = [\"substack.sid\", \"__cf_bm\", \"substack.lli\"];\n        log(\"Cookies:\", cookies);\n        const relevantCookies = cookies.filter((c) =>\n          relevantCookieNames.includes(c.name)\n        );\n\n        if (relevantCookies.length === 0) {\n          console.warn(\"No relevant Substack auth cookies found.\");\n          resolve({\n            message: \"No relevant Substack auth cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        const cookieDetails = relevantCookies.map((cookie) => ({\n          name: cookie.name,\n          value: cookie.value,\n          expiresAt: cookie.expirationDate || null,\n          domain: cookie.domain,\n          path: cookie.path,\n          secure: cookie.secure,\n          httpOnly: cookie.httpOnly,\n          sameSite: cookie.sameSite || \"unspecified\",\n        }));\n\n        const result = JSON.stringify(cookieDetails);\n\n        resolve({\n          message: \"Cookies fetched successfully\",\n          action: \"SUBSTACK_COOKIES_FETCHED\",\n          result: result,\n        });\n      });\n    });\n  },\n\n  // Create a post on Substack\n  createSubstackPost: async (bodyJson: any) => {\n    try {\n      const body =\n        typeof bodyJson === \"string\" ? bodyJson : JSON.stringify(bodyJson);\n\n      const response = await fetch(\"https://substack.com/api/v1/comment/feed\", {\n        headers: {\n          \"content-type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n        },\n        body,\n        method: \"POST\",\n      });\n      const data = await response.json();\n      if (!response.ok) {\n        log(\"Response:\", response);\n        log(\"Data:\", data);\n        return {\n          message: \"Failed to create post\",\n          action: \"SUBSTACK_POST_CREATED\",\n          result: JSON.stringify({ error: \"Failed to create post\" }),\n        };\n      }\n      log(\"Response:\", response);\n      log(\"Data after post sent:\", data);\n      return {\n        message: \"Post created successfully\",\n        action: \"SUBSTACK_POST_CREATED\",\n        result: JSON.stringify(data),\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      log(\"Error creating Substack post\", { error: errorMessage });\n      logError(\"Error creating Substack post:\", error);\n      throw error;\n    }\n  },\n\n  setSubstackCookies: async () => {\n    const response = await apiHandlers.getSubstackCookies();\n    const parsedCookies = JSON.parse(response.result);\n    log(\"Sending to server:\", JSON.stringify(parsedCookies));\n\n    try {\n      const cookiesResponse = await fetch(`${API_BASE_URL}/api/user/cookies`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(parsedCookies),\n      });\n      if (!cookiesResponse.ok) {\n        logError(\"Failed to send cookies to server\");\n        return response;\n      }\n      const data = await cookiesResponse.json();\n      log(\"Cookies sent to server successfully\", data);\n      return response;\n    } catch (error) {\n      logError(\"Error sending cookies to server:\", error);\n      return response;\n    }\n  },\n\n  // Create a new schedule\n  createSchedule: async (\n    scheduleId: string,\n    userId: string,\n    timestamp: number\n  ): Promise<Response<Schedule>> => {\n    try {\n      // Create schedule in extension storage\n      log(\"Creating schedule\", { scheduleId, userId, timestamp });\n      const schedule = await createSchedule(scheduleId, userId, timestamp);\n      log(\"Schedule created successfully\", schedule);\n      return {\n        message: \"Schedule created successfully\",\n        action: \"SCHEDULE_CREATED\",\n        result: schedule,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error creating schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  deleteSchedule: async (scheduleId: string): Promise<Response<boolean>> => {\n    try {\n      // Delete schedule from extension storage\n      const result = await deleteSchedule(scheduleId);\n      return {\n        message: result\n          ? \"Schedule deleted successfully\"\n          : \"Schedule not found\",\n        action: \"SCHEDULE_DELETED\",\n        result,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error deleting schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Get all schedules\n  getSchedules: async (): Promise<\n    Response<{ schedules: Schedule[]; alarms: Alarm[] }>\n  > => {\n    try {\n      // Get schedules from extension storage\n      const { schedules, alarms } = await getSchedules();\n      return {\n        message: `Found ${schedules.length} schedules`,\n        action: \"SCHEDULES_FETCHED\",\n        result: { schedules, alarms },\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error getting schedules:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Upload multiple images to Substack\n  uploadImagesToSubstack: async (\n    imageUrls: string[]\n  ): Promise<Response<ImageUploadResult[]>> => {\n    log(\"Uploading images to Substack:\", imageUrls);\n\n    if (!imageUrls || !imageUrls.length) {\n      return {\n        message: \"No images to upload\",\n        action: \"IMAGES_UPLOADED\",\n        result: [],\n      };\n    }\n\n    // Process each image URL, tracking results\n    const results: ImageUploadResult[] = [];\n\n    try {\n      // Use prepareAttachmentsForNote to process all images\n      const attachments = await prepareAttachmentsForNote(imageUrls);\n\n      // Create result entries for successful uploads\n      const successfulUploads = new Map<string, NoteDraftImage>();\n      attachments.forEach((attachment) => {\n        successfulUploads.set(attachment.url, attachment);\n      });\n\n      // Create result for each original URL\n      for (const imageUrl of imageUrls) {\n        const attachment = successfulUploads.get(imageUrl);\n\n        if (attachment) {\n          results.push({\n            url: imageUrl,\n            success: true,\n            attachmentId: attachment.id,\n          });\n        } else {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Successfully uploaded ${attachments.length} of ${imageUrls.length} images`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error uploading images to Substack:\", errorMessage);\n\n      // For any remaining URLs not in results, add failed entries\n      const processedUrls = new Set(results.map((r) => r.url));\n\n      for (const imageUrl of imageUrls) {\n        if (!processedUrls.has(imageUrl)) {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Error uploading images: ${errorMessage}`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    }\n  },\n};\n\n// Define message types\ninterface ApiRequestMessage {\n  type: \"API_REQUEST\" | \"PING\";\n  action: keyof ApiHandlers;\n  params?: unknown[];\n}\n\ninterface GenerateIdeasMessage {\n  type: \"GENERATE_IDEAS\";\n}\n\ntype ChromeMessage = ApiRequestMessage | GenerateIdeasMessage;\n\n// Helper function to safely call API handlers with dynamic parameters\nfunction callApiHandler(\n  action: keyof ApiHandlers,\n  params: unknown[] = []\n): Promise<any> {\n  switch (action) {\n    case \"getSubstackCookies\":\n      return apiHandlers.getSubstackCookies();\n    case \"setSubstackCookies\":\n      return apiHandlers.setSubstackCookies();\n    case \"createSubstackPost\":\n      return apiHandlers.createSubstackPost(\n        params[0] as string | undefined,\n        params[1] as number | undefined,\n        params[2] as boolean | undefined\n      );\n    case \"createSchedule\":\n      return apiHandlers.createSchedule(\n        params[0] as string,\n        params[1] as string,\n        params[2] as number\n      );\n    case \"deleteSchedule\":\n      return apiHandlers.deleteSchedule(params[0] as string);\n    case \"getSchedules\":\n      return apiHandlers.getSchedules();\n    case \"uploadImagesToSubstack\":\n      return apiHandlers.uploadImagesToSubstack(params[0] as string[]);\n    default:\n      return Promise.reject(new Error(`Unknown action: ${action}`));\n  }\n}\n\nlet isSending = false;\n\n// Set up alarm listener for schedule triggers\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n  log(`Alarm triggered: ${alarm.name}`);\n\n  // Check if this is a schedule alarm\n  const { schedules } = await getSchedules();\n  const schedule = schedules.find((s) => s.scheduleId === alarm.name);\n\n  if (schedule) {\n    log(`Processing schedule: ${schedule.scheduleId}`);\n    try {\n      await handleScheduleTrigger(schedule);\n\n      // Delete the schedule after processing\n      await deleteSchedule(schedule.scheduleId);\n    } catch (error) {\n      logError(`Error handling schedule ${schedule.scheduleId}:`, error);\n    }\n  }\n});\n\nchrome.runtime.onMessageExternal.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    log(\"Background script received external message:\", {\n      request,\n      sender: sender?.url,\n      type: request?.type,\n    });\n\n    // Handle PING message - respond immediately without async\n    if (request?.type === \"PING\") {\n      log(\"Received external PING, responding immediately\");\n      const version = chrome.runtime.getManifest().version;\n      log(\"Version:\", version);\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        version,\n        message: \"Extension is active\",\n        source: \"external\",\n      });\n      return false; // No async response needed\n    }\n\n    // Handle API requests\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      log(\"Received API request:\", { action, params });\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            logError(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n        return true; // Will respond asynchronously\n      }\n    }\n\n    return false;\n  }\n);\n\nchrome.runtime.onMessage.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    log(\"Background got internal message:\", request);\n\n    if (request?.type === \"PING\") {\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        message: \"Extension is active\",\n        source: \"internal\",\n      });\n      return false;\n    }\n\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      log(\"API request:\", { action, params });\n\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            logError(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n);\n\n// Initialize the extension\nasync function initializeExtension() {\n  log(\"Initializing extension...\");\n\n  // Check for any pending schedules\n  const { schedules, alarms } = await getSchedules();\n  if (schedules.length > 0) {\n    log(`Found ${schedules.length} schedules`);\n\n    // Process any schedules that should have already been triggered\n    const now = Date.now();\n    // const pastSchedules = schedules.filter((s) => s.timestamp <= now);\n\n    // if (pastSchedules.length > 0) {\n    //   console.log(`Processing ${pastSchedules.length} past schedules`);\n\n    //   for (const schedule of pastSchedules) {\n    //     try {\n    //       await handleScheduleTrigger(schedule);\n    //       await deleteSchedule(schedule.scheduleId);\n    //     } catch (error) {\n    //       console.error(\n    //         `Error handling past schedule ${schedule.scheduleId}:`,\n    //         error\n    //       );\n    //     }\n    //   }\n    // }\n\n    // Set up alarms for future schedules\n    const futureSchedules = schedules.filter((s) => s.timestamp > now);\n    if (futureSchedules.length > 0) {\n      log(`Setting up alarms for ${futureSchedules.length} future schedules`);\n\n      for (const schedule of futureSchedules) {\n        try {\n          chrome.alarms.create(schedule.scheduleId, {\n            when: schedule.timestamp,\n          });\n          log(\n            `Alarm created for schedule ${schedule.scheduleId} at ${new Date(\n              schedule.timestamp\n            ).toISOString()}`\n          );\n        } catch (error) {\n          logError(\n            `Error creating alarm for schedule ${schedule.scheduleId}:`,\n            error\n          );\n        }\n      }\n    }\n  }\n}\n\n// Run initialization\ninitializeExtension().catch((error) => {\n  logError(\"Error initializing extension:\", error);\n});\n"],"names":["API_BASE_URL","LOG_ENDPOINT","log","message","data","payload","error","logError","SCHEDULES_STORAGE_KEY","createSchedule","scheduleId","userId","timestamp","schedules","alarms","getSchedules","schedule","newSchedule","updatedSchedules","saveSchedules","createAlarmForSchedule","allAlarms","deleteSchedule","a","makeAuthenticatedRequest","endpoint","options","baseUrl","url","response","text","json","downloadImage","responseText","arrayBuffer","uploadImageSubstack","image","dataUri","arrayBufferToBase64","uploadImageResponse","getImageResponse","imageData","noteDraftImage","buffer","binary","bytes","len","i","prepareAttachmentsForNote","urls","maxAttachments","attachmentsToUpload","attachments","substackImage","getScheduleTriggerAPI","getScheduleAPI","handleScheduleTrigger","_a","freshSchedule","s","getSchedule","notifyScheduleTrigger","postResult","postToSubstack","ok","body","requestBody","bodyContent","apiHandlers","resolve","reject","cookies","relevantCookieNames","relevantCookies","c","cookieDetails","cookie","result","bodyJson","errorMessage","parsedCookies","cookiesResponse","imageUrls","results","successfulUploads","attachment","imageUrl","processedUrls","r","callApiHandler","action","params","alarm","request","sender","sendResponse","version","initializeExtension","now","futureSchedules"],"mappings":"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"}