{"version":3,"file":"background.js","sources":["../../src/content/background.ts"],"sourcesContent":["// background.ts\nimport { getState } from \"../lib/storage/chromeStorage\";\nimport { IdeaStatus } from \"@/types/idea\";\n\n// Base URL for API requests\nconst API_BASE_URL = \"http://localhost:3000\";\n\n// Queue for scheduled posts\ninterface ScheduledPost {\n  id: string;\n  message: string;\n  scheduledTime: number;\n  status: \"pending\" | \"processing\" | \"completed\" | \"failed\";\n  error?: string;\n  autoCloseTab?: boolean;\n}\n\n// Store posts in chrome.storage for persistence across extension reloads\nlet scheduledPosts: ScheduledPost[] = [];\n\n// Load scheduled posts from storage on initialization\nchrome.storage.local.get('scheduledPosts', (result) => {\n  if (result.scheduledPosts) {\n    scheduledPosts = result.scheduledPosts;\n    logScheduledPost(\"Loaded scheduled posts from storage\", { count: scheduledPosts.length });\n    \n    // Re-schedule any pending posts that should still be executed\n    const now = Date.now();\n    scheduledPosts.forEach(post => {\n      if (post.status === \"pending\" && post.scheduledTime > now) {\n        // Calculate remaining time\n        const remainingTime = post.scheduledTime - now;\n        if (remainingTime > 0 && remainingTime < 86400000) { // Only reschedule if less than 24 hours\n          logScheduledPost(\"Re-scheduling post after extension reload\", { \n            postId: post.id, \n            remainingTime: Math.round(remainingTime / 1000) + \"s\" \n          });\n          setTimeout(() => {\n            executeScheduledPost(post.id);\n          }, remainingTime);\n        }\n      }\n    });\n  }\n});\n\n// Function to save posts to storage\nfunction saveScheduledPosts() {\n  chrome.storage.local.set({ scheduledPosts }, () => {\n    if (chrome.runtime.lastError) {\n      console.error(\"Error saving scheduled posts:\", chrome.runtime.lastError);\n    }\n  });\n}\n\n// Enhanced logging function\nfunction logScheduledPost(message: string, data?: any) {\n  const timestamp = new Date().toISOString();\n  console.log(`[SCHEDULED POST ${timestamp}] ${message}`, data ? data : '');\n}\n\nasync function makeAuthenticatedRequest(\n  endpoint: string,\n  options: RequestInit = {}\n) {\n  const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n    ...options,\n    credentials: \"include\", // Include cookies automatically\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options.headers,\n    },\n  });\n\n  if (!response.ok) {\n    return null;\n  }\n\n  return response.json();\n}\n\n// Define API handler types\ntype ApiHandlers = {\n  updateIdeaStatus: (\n    ideaId: string,\n    status: IdeaStatus | \"favorite\"\n  ) => Promise<any>;\n  updateIdeaContent: (\n    ideaId: string,\n    body: string,\n    title: string,\n    subtitle: string\n  ) => Promise<any>;\n  generateIdeas: (\n    topic?: string,\n    ideasCount?: number,\n    shouldSearch?: boolean\n  ) => Promise<any>;\n  improveText: (text: string, type: string, ideaId: string) => Promise<any>;\n  improveTitle: (\n    menuType: \"title\" | \"subtitle\",\n    improveType: string,\n    ideaId: string,\n    value: string\n  ) => Promise<any>;\n  createNewIdea: () => Promise<any>;\n  generateIdeasTest: () => Promise<any>;\n  createSubstackPost: (\n    message?: string,\n    scheduleSeconds?: number,\n    autoCloseTab?: boolean\n  ) => Promise<any>;\n  getScheduledPosts: () => Promise<any>;\n};\n\n// API request handlers\nconst apiHandlers: ApiHandlers = {\n  // Idea status update\n  updateIdeaStatus: async (ideaId: string, status: IdeaStatus | \"favorite\") => {\n    const searchParamsStatus =\n      status === \"favorite\" ? \"isFavorite=true\" : `status=${status}`;\n    return makeAuthenticatedRequest(\n      `/api/idea/${ideaId}/status?${searchParamsStatus}`,\n      {\n        method: \"PATCH\",\n      }\n    );\n  },\n\n  // Idea content update\n  updateIdeaContent: async (\n    ideaId: string,\n    body: string,\n    title: string,\n    subtitle: string\n  ) => {\n    return makeAuthenticatedRequest(`/api/idea/${ideaId}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        body,\n        title,\n        subtitle,\n      }),\n    });\n  },\n\n  // Generate ideas\n  generateIdeas: async (\n    topic: string = \"\",\n    ideasCount: number = 3,\n    shouldSearch: boolean = false\n  ) => {\n    return makeAuthenticatedRequest(\n      `/api/post/generate/ideas?topic=${topic}&ideasCount=${ideasCount}&shouldSearch=${shouldSearch}`\n    );\n  },\n\n  // Improve text\n  improveText: async (text: string, type: string, ideaId: string) => {\n    return makeAuthenticatedRequest(\"/api/post/improve\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        text,\n        type,\n        ideaId,\n      }),\n    });\n  },\n\n  // Improve title or subtitle\n  improveTitle: async (\n    menuType: \"title\" | \"subtitle\",\n    improveType: string,\n    ideaId: string,\n    value: string\n  ) => {\n    return makeAuthenticatedRequest(\"/api/post/improve/title\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        menuType,\n        improveType,\n        ideaId,\n        value,\n      }),\n    });\n  },\n\n  // Create new idea\n  createNewIdea: async () => {\n    return makeAuthenticatedRequest(\"/api/idea\", {\n      method: \"POST\",\n    });\n  },\n\n  // Test idea generation (legacy handler)\n  generateIdeasTest: async () => {\n    return makeAuthenticatedRequest(\"/api/post/generate/ideas-test\");\n  },\n\n  // Create a post on Substack\n  createSubstackPost: async (\n    message: string = \"This is a test that was posted automatically with WriteRoom Chrome extension.\",\n    scheduleSeconds: number = 0,\n    autoCloseTab: boolean = true\n  ) => {\n    try {\n      logScheduledPost(\"createSubstackPost called\", { message, scheduleSeconds, autoCloseTab });\n      \n      // If scheduleSeconds is provided, schedule the post for later\n      if (scheduleSeconds > 0) {\n        const postId = Date.now().toString();\n        const scheduledTime = Date.now() + scheduleSeconds * 1000;\n\n        logScheduledPost(\"Scheduling post for later\", { postId, scheduledTime, autoCloseTab });\n\n        // Add to scheduled posts queue\n        const scheduledPost: ScheduledPost = {\n          id: postId,\n          message,\n          scheduledTime,\n          status: \"pending\",\n          autoCloseTab\n        };\n\n        scheduledPosts.push(scheduledPost);\n        saveScheduledPosts(); // Save to storage after adding\n\n        logScheduledPost(\"Added post to queue\", { queueLength: scheduledPosts.length });\n        \n        // Set up a timeout to execute the post\n        logScheduledPost(\"Setting timeout for execution\", { delaySeconds: scheduleSeconds });\n        setTimeout(() => {\n          logScheduledPost(\"Timeout triggered, executing scheduled post\", { postId });\n          executeScheduledPost(postId);\n        }, scheduleSeconds * 1000);\n        \n        return {\n          success: true,\n          scheduled: true,\n          message: `Post scheduled to be published in ${scheduleSeconds} seconds`,\n          postId,\n        };\n      }\n\n      logScheduledPost(\"Proceeding with immediate posting\");\n      \n      // Otherwise, proceed with immediate posting\n      // First, check if we have the necessary permissions\n      const hasPermissions = await checkSubstackPermissions();\n      logScheduledPost(\"Permission check result\", { hasPermissions });\n      \n      if (!hasPermissions) {\n        throw new Error(\"Missing scripting permission\");\n      }\n\n      // Find or create a tab with Substack, but activate it for immediate posting\n      logScheduledPost(\"Opening Substack tab\");\n      const tab = await openSubstackTab(true); // Pass true to activate the tab for immediate posting\n      logScheduledPost(\"Tab opened\", { tabId: tab?.id });\n      \n      if (!tab || !tab.id) {\n        throw new Error(\"Failed to open Substack tab\");\n      }\n\n      // Wait for the page to load\n      logScheduledPost(\"Waiting for page to load\");\n      await new Promise((resolve) => setTimeout(resolve, 5000));\n\n      // First check if the user is logged in\n      logScheduledPost(\"Checking if user is logged in\");\n      const loginCheckResult = await chrome.scripting.executeScript({\n        target: { tabId: tab.id },\n        func: checkIfLoggedIn,\n        args: [],\n      });\n\n      const isLoggedIn = loginCheckResult[0]?.result;\n      logScheduledPost(\"Login check result\", { isLoggedIn });\n      \n      if (!isLoggedIn) {\n        throw new Error(\n          \"You need to be logged in to Substack to post. Please log in and try again.\"\n        );\n      }\n\n      // Execute script to create a post\n      logScheduledPost(\"Executing script to create post\");\n      const result = await chrome.scripting.executeScript({\n        target: { tabId: tab.id },\n        func: createPost,\n        args: [message],\n      });\n      logScheduledPost(\"Script execution result\", result);\n\n      return { success: true, message: \"Post created successfully\", result };\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logScheduledPost(\"Error creating Substack post\", { error: errorMessage });\n      console.error(\"Error creating Substack post:\", error);\n      return { success: false, error: errorMessage };\n    }\n  },\n\n  // Get all scheduled posts\n  getScheduledPosts: async () => {\n    try {\n      logScheduledPost(\"Getting scheduled posts\", { count: scheduledPosts.length });\n      \n      // Check for extension context validity\n      if (!chrome.runtime || chrome.runtime.lastError) {\n        throw new Error(chrome.runtime.lastError?.message || \"Extension context invalid\");\n      }\n      \n      return {\n        success: true,\n        posts: scheduledPosts.map((post) => ({\n          id: post.id,\n          message: post.message,\n          scheduledTime: post.scheduledTime,\n          status: post.status,\n          error: post.error,\n          autoCloseTab: post.autoCloseTab\n        })),\n      };\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error(\"Error fetching scheduled posts:\", error);\n      return { success: false, error: errorMessage };\n    }\n  },\n};\n\n// Helper function to check if we have the necessary permissions\nasync function checkSubstackPermissions(): Promise<boolean> {\n  // In Manifest V3, host permissions are granted at install time\n  // We just need to check if we have the scripting permission\n  return new Promise((resolve) => {\n    chrome.permissions.contains(\n      {\n        permissions: [\"scripting\"],\n      },\n      (result) => {\n        resolve(result);\n      }\n    );\n  });\n}\n\n// Helper function to open a Substack tab without activating it\nasync function openSubstackTab(activate: boolean = false): Promise<chrome.tabs.Tab> {\n  return new Promise((resolve) => {\n    // Always create a new tab for posting to avoid disrupting the user's current tab\n    // This prevents the current tab from being refreshed if it's already on Substack\n    chrome.tabs.create({ url: \"https://substack.com\", active: activate }, (tab) => {\n      resolve(tab);\n    });\n  });\n}\n\n// Function to check if the user is logged in to Substack\nfunction checkIfLoggedIn(): boolean {\n  // Check for elements that indicate a logged-in state\n  // This could be a profile picture, user menu, etc.\n  // const userMenuElement = document.querySelector('.avatar-image') ||\n  //                         document.querySelector('.user-menu-button') ||\n  //                         document.querySelector('[data-testid=\"UserAvatar\"]');\n\n  // return !!userMenuElement;\n  return true;\n}\n\n// Function to be injected into the Substack page\nfunction createPost(message: string): { success: boolean; error?: string } {\n  try {\n    console.log(\"[SCHEDULED POST - INJECTED] Starting createPost function\", { message });\n    console.log(\"[SCHEDULED POST - INJECTED] Current URL:\", window.location.href);\n    console.log(\"[SCHEDULED POST - INJECTED] Page title:\", document.title);\n    \n    // Force log the body HTML to see what we're working with\n    console.log(\"[SCHEDULED POST - INJECTED] First 1000 chars of body HTML:\", \n      document.body ? document.body.innerHTML.substring(0, 1000) : \"No body found\");\n    \n    // If we're not on the main feed page, navigate there\n    if (\n      !window.location.href.includes(\"substack.com\") ||\n      (window.location.pathname !== \"/\" &&\n        window.location.pathname !== \"/home\" &&\n        !window.location.pathname.includes(\"/p/\"))\n    ) {\n      console.log(\"[SCHEDULED POST - INJECTED] Not on main feed, navigating\", { currentUrl: window.location.href });\n      window.location.href = \"https://substack.com/\";\n      return { success: false, error: \"Navigating to Substack home page\" };\n    }\n    \n    // DIRECT APPROACH: Instead of waiting and searching, let's create our own post interface\n    console.log(\"[SCHEDULED POST - INJECTED] Using direct approach to create post\");\n    \n    // Helper function to log HTML details of an element\n    function logElementDetails(element: Element, description: string) {\n      console.log(`[SCHEDULED POST - INJECTED] ${description}:`, {\n        tagName: element.tagName,\n        id: element.id,\n        className: element.className,\n        textContent: element.textContent?.substring(0, 50) + (element.textContent && element.textContent.length > 50 ? '...' : ''),\n        html: element.outerHTML.substring(0, 200) + (element.outerHTML.length > 200 ? '...' : '')\n      });\n    }\n    \n    // Create a function to check DOM until post creator button is found\n    function checkAndClickPostButton() {\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1: Starting composer search\");\n      \n      // New specific methods for Substack\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0: Trying direct Substack-specific methods first\");\n      \n      // Method 1: Look for specific Substack elements first\n      const composeButton = document.querySelector('a[href=\"/publish/post/new\"]') || \n                           document.querySelector('a[href*=\"new-post\"]') ||\n                           document.querySelector('a[data-testid=\"new-post-button\"]');\n      \n      if (composeButton) {\n        console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0.1: Found direct compose button\");\n        logElementDetails(composeButton as Element, \"Compose button details\");\n        \n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0.2: CLICKING direct compose button\");\n          (composeButton as HTMLElement).click();\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0.3: Click executed successfully\");\n          return true;\n        } catch (clickError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 1.0.4: Error clicking compose button:\", clickError);\n        }\n      }\n      \n      // Method 2: Look for 'New post' or 'Write' text on links or buttons\n      const newPostElements = Array.from(document.querySelectorAll('a, button'))\n        .filter(el => {\n          const text = el.textContent?.trim().toLowerCase() || '';\n          return text === 'new post' || text === 'write' || text.includes('create post');\n        });\n      \n      if (newPostElements.length > 0) {\n        const newPostButton = newPostElements[0];\n        console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0.5: Found 'New post' button by text\");\n        logElementDetails(newPostButton, \"New post button details\");\n        \n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0.6: CLICKING 'New post' button\");\n          (newPostButton as HTMLElement).click();\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.0.7: Click executed successfully\");\n          return true;\n        } catch (clickError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 1.0.8: Error clicking 'New post' button:\", clickError);\n        }\n      }\n      \n      // Fallback to standard methods if Substack-specific methods fail\n      \n      // Try all possible selectors for the post creator button\n      const possibleSelectors = [\n        // Try class-based selectors\n        '.inlineComposer-v8PLSi',\n        '.inline-composer',\n        '[class*=\"composer\"]',\n        // Try by role\n        'div[role=\"button\"]',\n        // Try by placeholder text\n        '[placeholder*=\"post\"]',\n        '[placeholder*=\"write\"]',\n        '[placeholder*=\"mind\"]',\n      ];\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1.1: Logging all divs with role=button\");\n      // Log all available divs with role=button to help diagnosis\n      const roleButtons = document.querySelectorAll('div[role=\"button\"]');\n      console.log(\"[SCHEDULED POST - INJECTED] Found \" + roleButtons.length + \" divs with role=button\");\n      Array.from(roleButtons).forEach((el, i) => {\n        console.log(`[SCHEDULED POST - INJECTED] Button ${i}: text=\"${el.textContent}\", innerHTML=\"${el.innerHTML.substring(0, 100)}...\"`);\n      });\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1.2: Trying each selector\");\n      // Try each selector\n      for (const selector of possibleSelectors) {\n        const elements = document.querySelectorAll(selector);\n        console.log(`[SCHEDULED POST - INJECTED] Selector \"${selector}\" matched ${elements.length} elements`);\n        \n        if (elements.length > 0) {\n          console.log(`[SCHEDULED POST - INJECTED] STEP 1.3: Found ${elements.length} elements with selector \"${selector}\"`);\n          \n          // Look for one that resembles a composer\n          for (const el of Array.from(elements)) {\n            const text = el.textContent || '';\n            if (text.includes(\"What's on your mind\") || text.includes(\"post\") || text.includes(\"Share\") || text.includes(\"Write\")) {\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 1.4: Found composer with matching text:\", text);\n              logElementDetails(el, \"Composer element details\");\n              \n              // Click it\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 1.5: CLICKING composer element\");\n              try {\n                (el as HTMLElement).click();\n                console.log(\"[SCHEDULED POST - INJECTED] STEP 1.6: Click executed successfully\");\n                return true;\n              } catch (clickError) {\n                console.error(\"[SCHEDULED POST - INJECTED] STEP 1.7: Error clicking composer:\", clickError);\n              }\n            }\n          }\n          \n          // If no text match found, just try the first element\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.8: No text match found, trying first matched element as composer\");\n          const firstElement = elements[0] as HTMLElement;\n          logElementDetails(firstElement, \"First matched element details\");\n          \n          try {\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 1.9: CLICKING first element\");\n            firstElement.click();\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 1.10: Click executed successfully\");\n            return true;\n          } catch (clickError) {\n            console.error(\"[SCHEDULED POST - INJECTED] STEP 1.11: Error clicking first element:\", clickError);\n          }\n        }\n      }\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1.12: No selectors matched, trying text-based div search\");\n      // If no selectors worked, try finding any div containing relevant text\n      const allDivs = document.querySelectorAll('div');\n      console.log(`[SCHEDULED POST - INJECTED] Searching through ${allDivs.length} divs for text matches`);\n      \n      let divWithText = null;\n      for (const div of Array.from(allDivs)) {\n        const text = div.textContent || '';\n        if (text.includes(\"What's on your mind\") || \n            text.includes(\"post\") || \n            text.includes(\"Share\") || \n            text.includes(\"Write\")) {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.13: Found div with relevant text:\", text);\n          logElementDetails(div, \"Text-matched div details\");\n          divWithText = div;\n          break;\n        }\n      }\n      \n      if (divWithText) {\n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.14: CLICKING text-matched div\");\n          (divWithText as HTMLElement).click();\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.15: Click executed successfully\");\n          return true;\n        } catch (clickError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 1.16: Error clicking text-matched div:\", clickError);\n        }\n      }\n      \n      // Last resort: try clicking on all divs that look like buttons\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1.17: Trying to click any div that looks like a button\");\n      const buttonLikeDivs = Array.from(document.querySelectorAll('div')).filter(div => {\n        const style = window.getComputedStyle(div);\n        return (\n          style.cursor === 'pointer' || \n          div.getAttribute('role') === 'button' ||\n          (div.className && div.className.toLowerCase().includes('button'))\n        );\n      });\n      \n      console.log(`[SCHEDULED POST - INJECTED] Found ${buttonLikeDivs.length} button-like divs`);\n      \n      for (const buttonDiv of buttonLikeDivs) {\n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.18: CLICKING button-like div\");\n          logElementDetails(buttonDiv, \"Button-like div details\");\n          (buttonDiv as HTMLElement).click();\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 1.19: Click executed successfully\");\n          return true;\n        } catch (clickError) {\n          console.log(\"[SCHEDULED POST - INJECTED] Error clicking button-like div:\", clickError);\n        }\n      }\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 1.20: No suitable composer element found after all attempts\");\n      return false;\n    }\n    \n    // Function to find and populate editor\n    function findAndPopulateEditor() {\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 2: Starting editor search\");\n      \n      // Substack-specific approach: Try to find the title field first\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0: Looking for Substack title field\");\n      \n      // Wait a bit more for editor to fully load\n      console.log(\"[SCHEDULED POST - INJECTED] Pausing briefly to allow editor to fully load\");\n      \n      // Try title field by placeholder, role, or aria-label\n      const titleInputs = document.querySelectorAll('input[placeholder*=\"Title\"], input[aria-label*=\"title\"], div[role=\"textbox\"][aria-label*=\"title\"], h1[contenteditable=\"true\"]');\n      console.log(`[SCHEDULED POST - INJECTED] STEP 2.0.1: Found ${titleInputs.length} possible title inputs`);\n      \n      Array.from(titleInputs).forEach((el, i) => {\n        logElementDetails(el, `Title input ${i} details`);\n      });\n      \n      if (titleInputs.length > 0) {\n        const titleInput = titleInputs[0] as HTMLElement;\n        console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0.2: Using first element as title input\");\n        \n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0.3: Setting title\");\n          if (titleInput.tagName.toLowerCase() === 'input') {\n            (titleInput as HTMLInputElement).value = \"Test Post from WriteRoom\";\n            titleInput.dispatchEvent(new Event('input', { bubbles: true }));\n            titleInput.dispatchEvent(new Event('change', { bubbles: true }));\n          } else {\n            titleInput.focus();\n            titleInput.innerHTML = \"Test Post from WriteRoom\";\n            titleInput.dispatchEvent(new Event('input', { bubbles: true }));\n            titleInput.dispatchEvent(new Event('change', { bubbles: true }));\n          }\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0.4: Title set successfully\");\n        } catch (titleError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 2.0.5: Error setting title:\", titleError);\n        }\n      }\n      \n      // Look for Substack-specific editor elements\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0.6: Looking for main editor field\");\n      const editorContainers = document.querySelectorAll('.redactor-styles, .redactor-editor, [data-slate-editor=\"true\"], [role=\"textbox\"][contenteditable=\"true\"]');\n      \n      if (editorContainers.length > 0) {\n        console.log(`[SCHEDULED POST - INJECTED] STEP 2.0.7: Found ${editorContainers.length} possible editor containers`);\n        const editorContainer = editorContainers[0] as HTMLElement;\n        logElementDetails(editorContainer, \"Editor container details\");\n        \n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0.8: Setting editor content\");\n          editorContainer.focus();\n          editorContainer.innerHTML = `<p>${message}</p>`;\n          editorContainer.dispatchEvent(new Event('input', { bubbles: true }));\n          editorContainer.dispatchEvent(new Event('change', { bubbles: true }));\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 2.0.9: Editor content set successfully\");\n          return true;\n        } catch (editorError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 2.0.10: Error setting editor content:\", editorError);\n        }\n      }\n      \n      // Fallback to generic methods if Substack-specific methods fail\n\n      // Try to find contenteditable\n      const editables = document.querySelectorAll('[contenteditable=\"true\"]');\n      \n      if (editables.length > 0) {\n        const editor = editables[0] as HTMLElement;\n        console.log(\"[SCHEDULED POST - INJECTED] STEP 2.1: Found contenteditable element\");\n        logElementDetails(editor, \"Selected editor details\");\n        \n        try {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 2.2: Setting editor content\");\n          editor.focus();\n          editor.innerHTML = `<p>${message}</p>`;\n          editor.dispatchEvent(new Event('input', { bubbles: true }));\n          editor.dispatchEvent(new Event('change', { bubbles: true }));\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 2.3: Editor content set successfully\");\n          return true;\n        } catch (editorError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 2.4: Error setting editor content:\", editorError);\n        }\n      }\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 2.5: No editor found after all attempts\");\n      return false;\n    }\n    \n    // Function to find and click publish button\n    function findAndClickPublishButton() {\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 3: Looking for publish/post button\");\n      \n      // First, try the exact pencraft button classes from the current Substack interface\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 3.1: Looking for Substack's pencraft buttons\");\n      \n      // Look for any button with the primary class that indicates it's the main action button\n      const pencraftButtons = document.querySelectorAll('button.priority_primary-RfbeYt, button[class*=\"priority_primary\"]');\n      console.log(`[SCHEDULED POST - INJECTED] STEP 3.1.1: Found ${pencraftButtons.length} pencraft primary buttons`);\n      \n      // If pencraft buttons are found, check each one for text \"Post\" or \"Publish\"\n      if (pencraftButtons.length > 0) {\n        Array.from(pencraftButtons).forEach((button, i) => {\n          logElementDetails(button, `Pencraft button ${i} details`);\n        });\n        \n        // First try to find one with text \"Post\" exactly (case-insensitive)\n        for (const button of Array.from(pencraftButtons)) {\n          const buttonText = button.textContent?.trim().toLowerCase() || '';\n          console.log(`[SCHEDULED POST - INJECTED] STEP 3.1.2: Checking button with text: \"${buttonText}\"`);\n          \n          if (buttonText === 'post') {\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 3.1.3: Found exact Post button\");\n            try {\n              (button as HTMLElement).click();\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 3.1.4: Clicked Post button\");\n              return true;\n            } catch (clickError) {\n              console.error(\"[SCHEDULED POST - INJECTED] STEP 3.1.5: Error clicking Post button:\", clickError);\n            }\n          }\n        }\n        \n        // If no exact match, try the first primary button (likely the Post button)\n        console.log(\"[SCHEDULED POST - INJECTED] STEP 3.1.6: No exact Post button found, using first primary button\");\n        try {\n          (pencraftButtons[0] as HTMLElement).click();\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 3.1.7: Clicked first primary button\");\n          return true;\n        } catch (clickError) {\n          console.error(\"[SCHEDULED POST - INJECTED] STEP 3.1.8: Error clicking first primary button:\", clickError);\n        }\n      }\n      \n      // Try Substack-specific publish button selectors as fallback\n      const substackPublishSelectors = [\n        'button[data-testid=\"publish-button\"]',\n        'button[aria-label*=\"publish\"]',\n        'button.buttonNew-KfJF0Q:not([class*=\"secondary\"])',\n        'button.button--primary',\n        'button.primary',\n        'button.publish'\n      ];\n      \n      // Try each Substack-specific selector\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 3.2: Trying Substack-specific publish selectors\");\n      for (const selector of substackPublishSelectors) {\n        try {\n          const publishButtons = document.querySelectorAll(selector);\n          console.log(`[SCHEDULED POST - INJECTED] STEP 3.2.1: Selector \"${selector}\" matched ${publishButtons.length} elements`);\n          \n          if (publishButtons.length > 0) {\n            const publishButton = publishButtons[0] as HTMLElement;\n            logElementDetails(publishButton, \"Publish button details\");\n            \n            try {\n              publishButton.click();\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 3.2.2: Clicked publish button\");\n              \n              // Wait for confirmation dialog to appear\n              setTimeout(handlePublishConfirmation, 1500);\n              return true;\n            } catch (clickError) {\n              console.error(\"[SCHEDULED POST - INJECTED] STEP 3.2.3: Error clicking publish button:\", clickError);\n            }\n          }\n        } catch (selectorError) {\n          console.error(`[SCHEDULED POST - INJECTED] STEP 3.2.4: Error with selector \"${selector}\":`, selectorError);\n        }\n      }\n      \n      // Fallback: Look for any button with \"post\" or \"publish\" text content\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 3.3: Looking for buttons with 'post' or 'publish' text\");\n      const allButtons = document.querySelectorAll('button');\n      console.log(`[SCHEDULED POST - INJECTED] STEP 3.3.1: Found ${allButtons.length} buttons total`);\n      \n      // Log some buttons for debugging\n      Array.from(allButtons).slice(0, 5).forEach((button, i) => {\n        logElementDetails(button, `Button ${i} details`);\n      });\n      \n      // First try to find a button with exact \"Post\" text\n      for (const button of Array.from(allButtons)) {\n        const buttonText = button.textContent?.trim().toLowerCase() || '';\n        if (buttonText === 'post') {\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 3.3.2: Found button with exact 'post' text\");\n          logElementDetails(button, \"Post button details\");\n          \n          try {\n            (button as HTMLElement).click();\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 3.3.3: Clicked Post button\");\n            return true;\n          } catch (clickError) {\n            console.error(\"[SCHEDULED POST - INJECTED] STEP 3.3.4: Error clicking Post button:\", clickError);\n          }\n        }\n      }\n      \n      // Then try for contains \"post\" or \"publish\"\n      for (const button of Array.from(allButtons)) {\n        const buttonText = button.textContent?.toLowerCase() || '';\n        if (buttonText.includes('post') || buttonText.includes('publish')) {\n          console.log(`[SCHEDULED POST - INJECTED] STEP 3.3.5: Found button with text containing 'post' or 'publish': \"${buttonText}\"`);\n          logElementDetails(button, \"Post/Publish text button details\");\n          \n          try {\n            (button as HTMLElement).click();\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 3.3.6: Clicked post/publish text button\");\n            return true;\n          } catch (clickError) {\n            console.error(\"[SCHEDULED POST - INJECTED] STEP 3.3.7: Error clicking post/publish text button:\", clickError);\n          }\n        }\n      }\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 3.4: No post/publish button found after all attempts\");\n      return false;\n    }\n    \n    // Function to handle the publish confirmation dialog\n    function handlePublishConfirmation() {\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 4: Looking for confirmation dialog\");\n      \n      // Try to find confirmation dialog and buttons\n      const confirmSelectors = [\n        'button:contains(\"Publish now\")',\n        'button:contains(\"Confirm\")',\n        'button:contains(\"Yes\")',\n        'button.confirm',\n        'button.primary:not(:disabled)',\n        'div[role=\"dialog\"] button.primary'\n      ];\n      \n      // Try each confirmation selector\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 4.1: Trying confirmation dialog selectors\");\n      for (const selector of confirmSelectors) {\n        try {\n          const confirmButtons = document.querySelectorAll(selector);\n          console.log(`[SCHEDULED POST - INJECTED] STEP 4.1.1: Selector \"${selector}\" matched ${confirmButtons.length} elements`);\n          \n          if (confirmButtons.length > 0) {\n            const confirmButton = confirmButtons[0] as HTMLElement;\n            logElementDetails(confirmButton, \"Confirmation button details\");\n            \n            // If the text suggests this is a confirmation button, click it\n            const buttonText = confirmButton.textContent?.toLowerCase() || '';\n            if (buttonText.includes('publish') || buttonText.includes('confirm') || buttonText.includes('yes')) {\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 4.1.2: Found confirmation button with text:\", buttonText);\n              confirmButton.click();\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 4.1.3: Clicked confirmation button - POST CONFIRMED\");\n              return true;\n            }\n          }\n        } catch (selectorError) {\n          console.error(`[SCHEDULED POST - INJECTED] STEP 4.1.4: Error with selector \"${selector}\":`, selectorError);\n        }\n      }\n      \n      // Fallback: Look for any buttons in a dialog that might be a confirmation\n      console.log(\"[SCHEDULED POST - INJECTED] STEP 4.2: Looking for dialog buttons\");\n      const dialogElements = document.querySelectorAll('div[role=\"dialog\"], .modal, [class*=\"modal\"], [class*=\"dialog\"]');\n      \n      if (dialogElements.length > 0) {\n        console.log(`[SCHEDULED POST - INJECTED] STEP 4.2.1: Found ${dialogElements.length} possible dialogs`);\n        const dialog = dialogElements[0] as HTMLElement;\n        logElementDetails(dialog, \"Dialog details\");\n        \n        // Find buttons in the dialog\n        const dialogButtons = dialog.querySelectorAll('button');\n        console.log(`[SCHEDULED POST - INJECTED] STEP 4.2.2: Found ${dialogButtons.length} buttons in dialog`);\n        \n        // Log dialog buttons\n        Array.from(dialogButtons).forEach((btn, i) => {\n          logElementDetails(btn, `Dialog button ${i} details`);\n        });\n        \n        // Try to find a button that looks like a confirmation button\n        for (const btn of Array.from(dialogButtons)) {\n          const btnText = btn.textContent?.toLowerCase() || '';\n          \n          if (btnText.includes('publish') || btnText.includes('confirm') || btnText.includes('yes') || \n              btnText.includes('ok') || btnText.includes('submit')) {\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 4.2.3: Found likely confirmation button in dialog:\", btnText);\n            \n            try {\n              (btn as HTMLElement).click();\n              console.log(\"[SCHEDULED POST - INJECTED] STEP 4.2.4: Clicked dialog confirmation button - POST CONFIRMED\");\n              return true;\n            } catch (clickError) {\n              console.error(\"[SCHEDULED POST - INJECTED] STEP 4.2.5: Error clicking dialog confirmation button:\", clickError);\n            }\n          }\n        }\n        \n        // If no specific confirmation button found, try the last button (often the confirm action)\n        if (dialogButtons.length > 0) {\n          const lastButton = dialogButtons[dialogButtons.length - 1] as HTMLElement;\n          console.log(\"[SCHEDULED POST - INJECTED] STEP 4.2.6: Trying last button in dialog as confirmation\");\n          \n          try {\n            lastButton.click();\n            console.log(\"[SCHEDULED POST - INJECTED] STEP 4.2.7: Clicked last dialog button - POST LIKELY CONFIRMED\");\n            return true;\n          } catch (clickError) {\n            console.error(\"[SCHEDULED POST - INJECTED] STEP 4.2.8: Error clicking last dialog button:\", clickError);\n          }\n        }\n      }\n      \n      console.log(\"[SCHEDULED POST - INJECTED] STEP 4.3: No confirmation dialog or button found\");\n      return false;\n    }\n    \n    // Set up a sequence of operations with timeouts\n    console.log(\"[SCHEDULED POST - INJECTED] Setting up posting sequence with timeouts\");\n    setTimeout(() => {\n      console.log(\"[SCHEDULED POST - INJECTED] Phase 1: Finding and clicking composer\");\n      if (checkAndClickPostButton()) {\n        console.log(\"[SCHEDULED POST - INJECTED] Composer clicked successfully, waiting 3 seconds for editor to appear\");\n        setTimeout(() => {\n          console.log(\"[SCHEDULED POST - INJECTED] Phase 2: Finding and populating editor\");\n          if (findAndPopulateEditor()) {\n            console.log(\"[SCHEDULED POST - INJECTED] Editor populated successfully, waiting 3 seconds for publish button\");\n            setTimeout(() => {\n              console.log(\"[SCHEDULED POST - INJECTED] Phase 3: Finding and clicking publish button\");\n              if (findAndClickPublishButton()) {\n                console.log(\"[SCHEDULED POST - INJECTED] Publish button clicked successfully - POST COMPLETE\");\n              } else {\n                console.log(\"[SCHEDULED POST - INJECTED] Failed to find and click publish button\");\n              }\n            }, 3000);\n          } else {\n            console.log(\"[SCHEDULED POST - INJECTED] Failed to find and populate editor\");\n          }\n        }, 3000);\n      } else {\n        console.log(\"[SCHEDULED POST - INJECTED] Failed to find and click composer\");\n      }\n    }, 2000);\n\n    // Return immediately since we can't wait for the async process\n    return {\n      success: true,\n      error: \"Post operation started. Check the console for detailed logs.\"\n    };\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error(\"[SCHEDULED POST - INJECTED] Error in createPost:\", error);\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Define message types\ninterface ApiRequestMessage {\n  type: \"API_REQUEST\";\n  action: keyof ApiHandlers;\n  params?: unknown[];\n}\n\ninterface GenerateIdeasMessage {\n  type: \"GENERATE_IDEAS\";\n}\n\ntype ChromeMessage = ApiRequestMessage | GenerateIdeasMessage;\n\n// Helper function to safely call API handlers with dynamic parameters\nfunction callApiHandler(\n  action: keyof ApiHandlers,\n  params: unknown[] = []\n): Promise<any> {\n  switch (action) {\n    case \"updateIdeaStatus\":\n      return apiHandlers.updateIdeaStatus(\n        params[0] as string,\n        params[1] as IdeaStatus | \"favorite\"\n      );\n    case \"updateIdeaContent\":\n      return apiHandlers.updateIdeaContent(\n        params[0] as string,\n        params[1] as string,\n        params[2] as string,\n        params[3] as string\n      );\n    case \"generateIdeas\":\n      return apiHandlers.generateIdeas(\n        params[0] as string | undefined,\n        params[1] as number | undefined,\n        params[2] as boolean | undefined\n      );\n    case \"improveText\":\n      return apiHandlers.improveText(\n        params[0] as string,\n        params[1] as string,\n        params[2] as string\n      );\n    case \"improveTitle\":\n      return apiHandlers.improveTitle(\n        params[0] as \"title\" | \"subtitle\",\n        params[1] as string,\n        params[2] as string,\n        params[3] as string\n      );\n    case \"createNewIdea\":\n      return apiHandlers.createNewIdea();\n    case \"generateIdeasTest\":\n      return apiHandlers.generateIdeasTest();\n    case \"createSubstackPost\":\n      return apiHandlers.createSubstackPost(\n        params[0] as string | undefined,\n        params[1] as number | undefined,\n        params[2] as boolean | undefined\n      );\n    case \"getScheduledPosts\":\n      return apiHandlers.getScheduledPosts();\n    default:\n      return Promise.reject(new Error(`Unknown action: ${action}`));\n  }\n}\n\n// Listen for messages from content script\nchrome.runtime.onMessage.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    console.log(\"Background script received message:\", request);\n\n    // Handle API requests\n    if (request.type === \"API_REQUEST\") {\n      const { action, params } = request;\n\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            console.error(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n        return true; // Will respond asynchronously\n      }\n    }\n\n    // Legacy handler for backward compatibility\n    if (request.type === \"GENERATE_IDEAS\") {\n      apiHandlers\n        .generateIdeasTest()\n        .then((data: any) => {\n          sendResponse({ success: true, data });\n        })\n        .catch((error: Error) => {\n          console.error(\"Error generating ideas:\", error);\n          sendResponse({ success: false, error: error.message });\n        });\n      return true; // Will respond asynchronously\n    }\n  }\n);\n\n// Execute a scheduled post\nasync function executeScheduledPost(postId: string) {\n  // Find the post in the queue\n  const postIndex = scheduledPosts.findIndex((post) => post.id === postId);\n  logScheduledPost(\"Executing scheduled post\", { postId, postIndex });\n  \n  if (postIndex === -1) {\n    logScheduledPost(\"Post not found in queue\", { postId });\n    return;\n  }\n\n  // Update status to processing\n  scheduledPosts[postIndex].status = \"processing\";\n  saveScheduledPosts(); // Save state update\n  logScheduledPost(\"Updated post status to processing\", { postId });\n\n  let tab: chrome.tabs.Tab | null = null;\n\n  try {\n    // First, check if we have the necessary permissions\n    logScheduledPost(\"Checking permissions\", { postId });\n    const hasPermissions = await checkSubstackPermissions();\n    logScheduledPost(\"Permission check result\", { postId, hasPermissions });\n    \n    if (!hasPermissions) {\n      throw new Error(\"Missing scripting permission\");\n    }\n\n    // Find or create a tab with Substack, but don't activate it\n    logScheduledPost(\"Opening Substack tab in background\", { postId });\n    tab = await openSubstackTab(false); // Pass false to not activate the tab\n    logScheduledPost(\"Tab opened in background\", { postId, tabId: tab?.id });\n    \n    if (!tab || !tab.id) {\n      throw new Error(\"Failed to open Substack tab\");\n    }\n\n    // Wait for the page to load - increased to 10 seconds\n    logScheduledPost(\"Waiting for page to fully load\", { postId });\n    await new Promise((resolve) => setTimeout(resolve, 10000));\n\n    // Check if the user is logged in\n    logScheduledPost(\"Checking if user is logged in\", { postId });\n    const loginCheckResult = await chrome.scripting.executeScript({\n      target: { tabId: tab.id },\n      func: checkIfLoggedIn,\n      args: [],\n    });\n\n    const isLoggedIn = loginCheckResult[0]?.result;\n    logScheduledPost(\"Login check result\", { postId, isLoggedIn });\n    \n    if (!isLoggedIn) {\n      throw new Error(\"You need to be logged in to Substack to post\");\n    }\n\n    logScheduledPost(\"About to post message\", { \n      postId, \n      messagePreview: scheduledPosts[postIndex].message.substring(0, 30) + '...' \n    });\n\n    // Set up a listener for console messages from the tab\n    logScheduledPost(\"Setting up console monitoring\", { postId });\n    \n    // We'll use executeScript to inject a console interceptor instead of the debugger API\n    // This is more reliable and doesn't require the debugger permission\n    if (tab && tab.id) {\n      try {\n        chrome.scripting.executeScript({\n          target: { tabId: tab.id },\n          func: () => {\n            // Store the original console.log function\n            const originalLog = console.log;\n            \n            // Override console.log to capture our special messages\n            console.log = function(...args) {\n              // Call the original console.log\n              originalLog.apply(console, args);\n              \n              // Check if this is one of our special messages\n              const message = args.join(' ');\n              if (typeof message === 'string' && message.includes('[SCHEDULED POST - INJECTED]')) {\n                // Send a message to the parent window to capture this log\n                window.postMessage({\n                  type: 'SCHEDULED_POST_LOG',\n                  message: message\n                }, '*');\n              }\n            };\n            \n            // Set up a listener for our logs\n            window.addEventListener('message', (event) => {\n              if (event.data && event.data.type === 'SCHEDULED_POST_LOG') {\n                // This message will be visible in the DevTools console\n                originalLog('%c[CAPTURED LOG]', 'color: purple; font-weight: bold', event.data.message);\n              }\n            });\n          }\n        });\n        \n        logScheduledPost(\"Console monitoring set up successfully\", { postId });\n      } catch (error) {\n        logScheduledPost(\"Failed to set up console monitoring (this is non-critical)\", { \n          postId, \n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }\n\n    // Execute script to create a post\n    logScheduledPost(\"Executing script to create post\", { postId });\n    const result = await chrome.scripting.executeScript({\n      target: { tabId: tab.id },\n      func: createPost,\n      args: [scheduledPosts[postIndex].message],\n    });\n    logScheduledPost(\"Script execution result\", { postId, result });\n\n    // Wait longer for the posting process to complete\n    logScheduledPost(\"Waiting for posting process to complete\", { postId });\n    await new Promise((resolve) => setTimeout(resolve, 8000)); // Increased to 20 seconds for more verbose logging\n\n    // No need to detach the debugger anymore since we're not using it\n\n    // Update status to completed\n    scheduledPosts[postIndex].status = \"completed\";\n    saveScheduledPosts(); // Save state update\n    logScheduledPost(\"Updated post status to completed\", { postId });\n\n    // After successful posting, close the tab if autoCloseTab is true\n    const shouldCloseTab = scheduledPosts[postIndex].autoCloseTab !== false;\n    logScheduledPost(\"Checking if tab should be closed\", { postId, shouldCloseTab });\n    \n    if (shouldCloseTab) {\n      logScheduledPost(\"Setting timeout to close tab\", { postId });\n      setTimeout(() => {\n        if (tab && tab.id) {\n          logScheduledPost(\"Closing tab\", { postId, tabId: tab.id });\n          chrome.tabs.remove(tab.id);\n        }\n      }, 10000); // Increased from 5000 to 10000 ms (10 seconds)\n    } else {\n      logScheduledPost(\"Tab will remain open as requested\", { postId });\n    }\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logScheduledPost(\"Error executing scheduled post\", { postId, error: errorMessage });\n    console.error(\"Error executing scheduled post:\", error);\n\n    // Get detailed HTML of the tab if possible\n    if (tab && tab.id) {\n      try {\n        logScheduledPost(\"Attempting to capture tab contents for debugging\", { postId });\n        // Try to execute a script to get the HTML content for debugging\n        chrome.scripting.executeScript({\n          target: { tabId: tab.id },\n          func: () => {\n            return {\n              url: window.location.href,\n              title: document.title,\n              bodyText: document.body?.textContent?.substring(0, 1000) || \"No body text\",\n              html: document.documentElement.outerHTML\n            };\n          },\n        }).then(result => {\n          if (result && result[0]) {\n            const pageInfo = result[0].result;\n            logScheduledPost(\"Tab page info\", { \n              postId, \n              url: pageInfo.url,\n              title: pageInfo.title,\n              bodyTextPreview: pageInfo.bodyText + '...'\n            });\n            \n            // Log the most important parts of HTML for debugging\n            logScheduledPost(\"Tab HTML structure\", {\n              postId,\n              headContent: pageInfo.html.match(/<head>(.*?)<\\/head>/s)?.[0]?.substring(0, 500) + '...' || \"No head content found\",\n              bodyStructure: pageInfo.html.match(/<body.*?>(.*?)<\\/body>/s)?.[0]?.substring(0, 1000) + '...' || \"No body content found\"\n            });\n          }\n        }).catch(err => {\n          logScheduledPost(\"Failed to capture tab HTML\", { postId, error: err });\n        });\n      } catch (screenshotError) {\n        logScheduledPost(\"Error capturing tab content\", { \n          postId, \n          error: screenshotError instanceof Error ? screenshotError.message : String(screenshotError)\n        });\n      }\n    }\n\n    // Update status to failed\n    scheduledPosts[postIndex].status = \"failed\";\n    scheduledPosts[postIndex].error = errorMessage;\n    saveScheduledPosts(); // Save state update\n    logScheduledPost(\"Updated post status to failed\", { postId, error: errorMessage });\n  }\n}\n\nexport { makeAuthenticatedRequest };\n"],"names":["API_BASE_URL","scheduledPosts","result","logScheduledPost","now","post","remainingTime","executeScheduledPost","saveScheduledPosts","message","data","timestamp","makeAuthenticatedRequest","endpoint","options","response","apiHandlers","ideaId","status","searchParamsStatus","body","title","subtitle","topic","ideasCount","shouldSearch","text","type","menuType","improveType","value","scheduleSeconds","autoCloseTab","_a","postId","scheduledTime","scheduledPost","hasPermissions","checkSubstackPermissions","tab","openSubstackTab","resolve","isLoggedIn","checkIfLoggedIn","createPost","error","errorMessage","activate","logElementDetails","element","description","checkAndClickPostButton","composeButton","clickError","newPostElements","el","newPostButton","possibleSelectors","roleButtons","i","selector","elements","firstElement","allDivs","divWithText","div","buttonLikeDivs","buttonDiv","findAndPopulateEditor","titleInputs","titleInput","titleError","editorContainers","editorContainer","editorError","editables","editor","findAndClickPublishButton","_b","_c","pencraftButtons","button","buttonText","substackPublishSelectors","publishButtons","publishButton","handlePublishConfirmation","selectorError","allButtons","confirmSelectors","confirmButtons","confirmButton","dialogElements","dialog","dialogButtons","btn","btnText","lastButton","callApiHandler","action","params","request","sender","sendResponse","postIndex","originalLog","args","event","shouldCloseTab","_d","pageInfo","err","screenshotError"],"mappings":"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"}