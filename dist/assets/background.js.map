{"version":3,"file":"background.js","sources":["../../src/content/background.ts"],"sourcesContent":["// background.ts\nimport {\n  Alarm,\n  createSchedule,\n  deleteSchedule,\n  getSchedules,\n  Schedule,\n  ScheduleStatus,\n  updateScheduleStatus,\n} from \"../utils/scheduleUtils\";\nimport { handleScheduleTrigger } from \"../utils/scheduleTriggerService\";\nimport { NoteDraftImage, prepareAttachmentsForNote } from \"../utils/imageUtils\";\nimport { log, logError } from \"../utils/logger\";\n\n// Base URL for API requests\nconst API_BASE_URL = \"https://www.writestack.io\";\n\ninterface Response<T> {\n  message: string;\n  action: string;\n  result: T;\n}\n\n// Image upload result interface\ninterface ImageUploadResult {\n  url: string;\n  success: boolean;\n  attachmentId?: string;\n}\n\n// Enhanced logging function\nfunction logScheduledPost(message: string, data?: any) {\n  const timestamp = new Date().toISOString();\n  console.log(`[SCHEDULED POST ${timestamp}] ${message}`, data ? data : \"\");\n}\n\n// Define API handler types\ntype ApiHandlers = {\n  createSubstackPost: (\n    message?: string,\n    scheduleSeconds?: number,\n    autoCloseTab?: boolean\n  ) => Promise<Response<any>>;\n  getSubstackCookies: () => Promise<Response<string>>;\n  setSubstackCookies: () => Promise<Response<any>>;\n  createSchedule: (\n    scheduleId: string,\n    userId: string,\n    timestamp: number\n  ) => Promise<Response<Schedule>>;\n  deleteSchedule: (scheduleId: string) => Promise<Response<boolean>>;\n  getSchedules: () => Promise<\n    Response<{ schedules: Schedule[]; alarms: Alarm[] }>\n  >;\n  uploadImagesToSubstack: (\n    imageUrls: string[]\n  ) => Promise<Response<ImageUploadResult[]>>;\n};\n\n// API request handlers\nconst apiHandlers: ApiHandlers = {\n  getSubstackCookies: async (): Promise<Response<string>> => {\n    return new Promise((resolve, reject) => {\n      chrome.cookies.getAll({ domain: \"substack.com\" }, (cookies) => {\n        if (chrome.runtime.lastError) {\n          logError(\"Error fetching cookies:\", chrome.runtime.lastError);\n          reject(chrome.runtime.lastError.message);\n          return;\n        }\n\n        if (!cookies || cookies.length === 0) {\n          console.warn(\"No Substack cookies found.\");\n          resolve({\n            message: \"No Substack cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        // Only keep relevant cookies\n        const relevantCookieNames = [\"substack.sid\", \"__cf_bm\", \"substack.lli\"];\n        log(\"Cookies:\", cookies);\n        const relevantCookies = cookies.filter((c) =>\n          relevantCookieNames.includes(c.name)\n        );\n\n        if (relevantCookies.length === 0) {\n          console.warn(\"No relevant Substack auth cookies found.\");\n          resolve({\n            message: \"No relevant Substack auth cookies found.\",\n            action: \"SUBSTACK_COOKIES_FETCHED\",\n            result: \"\",\n          });\n          return;\n        }\n\n        const cookieDetails = relevantCookies.map((cookie) => ({\n          name: cookie.name,\n          value: cookie.value,\n          expiresAt: cookie.expirationDate || null,\n          domain: cookie.domain,\n          path: cookie.path,\n          secure: cookie.secure,\n          httpOnly: cookie.httpOnly,\n          sameSite: cookie.sameSite || \"unspecified\",\n        }));\n\n        const result = JSON.stringify(cookieDetails);\n\n        resolve({\n          message: \"Cookies fetched successfully\",\n          action: \"SUBSTACK_COOKIES_FETCHED\",\n          result: result,\n        });\n      });\n    });\n  },\n\n  // Create a post on Substack\n  createSubstackPost: async (bodyJson: any) => {\n    try {\n      const body =\n        typeof bodyJson === \"string\" ? bodyJson : JSON.stringify(bodyJson);\n\n      const response = await fetch(\"https://substack.com/api/v1/comment/feed\", {\n        headers: {\n          \"content-type\": \"application/json\",\n          Referer: \"https://substack.com/home\",\n          Origin: \"https://substack.com\",\n        },\n        credentials: \"include\", // Required to send cookies\n        body,\n        method: \"POST\",\n      });\n      const data = await response.json();\n      if (!response.ok) {\n        log(\"Response:\", response);\n        log(\"Data:\", data);\n        return {\n          message: \"Failed to create post\",\n          action: \"SUBSTACK_POST_CREATED\",\n          result: JSON.stringify({ error: \"Failed to create post\" }),\n        };\n      }\n      log(\"Response:\", response);\n      log(\"Data after post sent:\", data);\n      return {\n        message: \"Post created successfully\",\n        action: \"SUBSTACK_POST_CREATED\",\n        result: JSON.stringify(data),\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      log(\"Error creating Substack post\", { error: errorMessage });\n      logError(\"Error creating Substack post:\", error);\n      throw error;\n    }\n  },\n\n  setSubstackCookies: async () => {\n    const response = await apiHandlers.getSubstackCookies();\n    const parsedCookies = JSON.parse(response.result);\n    log(\"Sending to server:\", JSON.stringify(parsedCookies));\n\n    try {\n      const cookiesResponse = await fetch(`${API_BASE_URL}/api/user/cookies`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(parsedCookies),\n      });\n      if (!cookiesResponse.ok) {\n        logError(\"Failed to send cookies to server\");\n        return response;\n      }\n      const data = await cookiesResponse.json();\n      log(\"Cookies sent to server successfully\", data);\n      return response;\n    } catch (error) {\n      logError(\"Error sending cookies to server:\", error);\n      return response;\n    }\n  },\n\n  // Create a new schedule\n  createSchedule: async (\n    scheduleId: string,\n    userId: string,\n    timestamp: number\n  ): Promise<Response<Schedule>> => {\n    try {\n      // Create schedule in extension storage\n      log(\"Creating schedule\", { scheduleId, userId, timestamp });\n      const schedule = await createSchedule(scheduleId, userId, timestamp);\n      log(\"Schedule created successfully\", schedule);\n      return {\n        message: \"Schedule created successfully\",\n        action: \"SCHEDULE_CREATED\",\n        result: schedule,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error creating schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  deleteSchedule: async (scheduleId: string): Promise<Response<boolean>> => {\n    try {\n      // Delete schedule from extension storage\n      const result = await deleteSchedule(scheduleId);\n      return {\n        message: result\n          ? \"Schedule deleted successfully\"\n          : \"Schedule not found\",\n        action: \"SCHEDULE_DELETED\",\n        result,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error deleting schedule:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Get all schedules\n  getSchedules: async (): Promise<\n    Response<{ schedules: Schedule[]; alarms: Alarm[] }>\n  > => {\n    try {\n      // Get schedules from extension storage\n      const { schedules, alarms } = await getSchedules();\n      return {\n        message: `Found ${schedules.length} schedules`,\n        action: \"SCHEDULES_FETCHED\",\n        result: { schedules, alarms },\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error getting schedules:\", errorMessage);\n      throw error;\n    }\n  },\n\n  // Upload multiple images to Substack\n  uploadImagesToSubstack: async (\n    imageUrls: string[]\n  ): Promise<Response<ImageUploadResult[]>> => {\n    log(\"Uploading images to Substack:\", imageUrls);\n\n    if (!imageUrls || !imageUrls.length) {\n      return {\n        message: \"No images to upload\",\n        action: \"IMAGES_UPLOADED\",\n        result: [],\n      };\n    }\n\n    // Process each image URL, tracking results\n    const results: ImageUploadResult[] = [];\n\n    try {\n      // Use prepareAttachmentsForNote to process all images\n      const attachments = await prepareAttachmentsForNote(imageUrls);\n\n      // Create result entries for successful uploads\n      const successfulUploads = new Map<string, NoteDraftImage>();\n      attachments.forEach((attachment) => {\n        successfulUploads.set(attachment.url, attachment);\n      });\n\n      // Create result for each original URL\n      for (const imageUrl of imageUrls) {\n        const attachment = successfulUploads.get(imageUrl);\n\n        if (attachment) {\n          results.push({\n            url: imageUrl,\n            success: true,\n            attachmentId: attachment.id,\n          });\n        } else {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Successfully uploaded ${attachments.length} of ${imageUrls.length} images`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logError(\"Error uploading images to Substack:\", errorMessage);\n\n      // For any remaining URLs not in results, add failed entries\n      const processedUrls = new Set(results.map((r) => r.url));\n\n      for (const imageUrl of imageUrls) {\n        if (!processedUrls.has(imageUrl)) {\n          results.push({\n            url: imageUrl,\n            success: false,\n          });\n        }\n      }\n\n      return {\n        message: `Error uploading images: ${errorMessage}`,\n        action: \"IMAGES_UPLOADED\",\n        result: results,\n      };\n    }\n  },\n};\n\n// Define message types\ninterface ApiRequestMessage {\n  type: \"API_REQUEST\" | \"PING\";\n  action: keyof ApiHandlers;\n  params?: unknown[];\n}\n\ninterface GenerateIdeasMessage {\n  type: \"GENERATE_IDEAS\";\n}\n\ntype ChromeMessage = ApiRequestMessage | GenerateIdeasMessage;\n\n// Helper function to safely call API handlers with dynamic parameters\nfunction callApiHandler(\n  action: keyof ApiHandlers,\n  params: unknown[] = []\n): Promise<any> {\n  switch (action) {\n    case \"getSubstackCookies\":\n      return apiHandlers.getSubstackCookies();\n    case \"setSubstackCookies\":\n      return apiHandlers.setSubstackCookies();\n    case \"createSubstackPost\":\n      return apiHandlers.createSubstackPost(\n        params[0] as string | undefined,\n        params[1] as number | undefined,\n        params[2] as boolean | undefined\n      );\n    case \"createSchedule\":\n      return apiHandlers.createSchedule(\n        params[0] as string,\n        params[1] as string,\n        params[2] as number\n      );\n    case \"deleteSchedule\":\n      return apiHandlers.deleteSchedule(params[0] as string);\n    case \"getSchedules\":\n      return apiHandlers.getSchedules();\n    case \"uploadImagesToSubstack\":\n      return apiHandlers.uploadImagesToSubstack(params[0] as string[]);\n    default:\n      return Promise.reject(new Error(`Unknown action: ${action}`));\n  }\n}\n\nlet isSending = false;\n\n// Set up alarm listener for schedule triggers\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n  log(`Alarm triggered: ${alarm.name}`);\n\n  // Check if this is a schedule alarm\n  const { schedules } = await getSchedules();\n  const schedule = schedules.find((s) => s.scheduleId === alarm.name);\n\n  if (schedule) {\n    log(`Processing schedule: ${schedule.scheduleId}`);\n    try {\n      const result = await handleScheduleTrigger(schedule);\n      log(`Schedule ${schedule.scheduleId} processed:`, result);\n      if (result.status === \"sent\") {\n        // Delete the schedule after processing\n        await deleteSchedule(schedule.scheduleId);\n      } else {\n        if (result.status === \"processing\") {\n          return;\n        }\n        // update the status and error\n        await updateScheduleStatus(\n          schedule.scheduleId,\n          result.status,\n          result.error\n        );\n      }\n    } catch (error) {\n      logError(`Error handling schedule ${schedule.scheduleId}:`, error);\n    }\n  }\n});\n\nchrome.runtime.onMessageExternal.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    log(\"Background script received external message:\", {\n      request,\n      sender: sender?.url,\n      type: request?.type,\n    });\n\n    // Handle PING message - respond immediately without async\n    if (request?.type === \"PING\") {\n      log(\"Received external PING, responding immediately\");\n      const version = chrome.runtime.getManifest().version;\n      log(\"Version:\", version);\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        version,\n        message: \"Extension is active\",\n        source: \"external\",\n      });\n      return false; // No async response needed\n    }\n\n    // Handle API requests\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      log(\"Received API request:\", { action, params });\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            logError(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n        return true; // Will respond asynchronously\n      }\n    }\n\n    return false;\n  }\n);\n\nchrome.runtime.onMessage.addListener(\n  (request: ChromeMessage, sender, sendResponse) => {\n    log(`Background got internal from ${sender.url} message: ${JSON.stringify(request)}`);\n\n    if (request?.type === \"PING\") {\n      sendResponse({\n        success: true,\n        timestamp: Date.now(),\n        message: \"Extension is active\",\n        source: \"internal\",\n      });\n      return false;\n    }\n\n    if (request?.type === \"API_REQUEST\") {\n      const { action, params } = request;\n      log(\"API request:\", { action, params });\n\n      if (action) {\n        callApiHandler(action, params)\n          .then((data: any) => {\n            sendResponse({ success: true, data });\n          })\n          .catch((error: Error) => {\n            logError(`Error in API request (${action}):`, error);\n            sendResponse({ success: false, error: error.message });\n          });\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n);\n"],"names":["API_BASE_URL","apiHandlers","resolve","reject","cookies","logError","relevantCookieNames","log","relevantCookies","c","cookieDetails","cookie","result","bodyJson","body","response","data","error","errorMessage","parsedCookies","cookiesResponse","scheduleId","userId","timestamp","schedule","createSchedule","deleteSchedule","schedules","alarms","getSchedules","imageUrls","results","attachments","prepareAttachmentsForNote","successfulUploads","attachment","imageUrl","processedUrls","r","callApiHandler","action","params","alarm","s","handleScheduleTrigger","updateScheduleStatus","request","sender","sendResponse","version"],"mappings":"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"}